{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Abstract GrowNode is a vertical framework to build esp32 based devices targeted to growing plants in a controlled environment. It is currently based on the work of Nicola Muratori and Adamo Ferro . Target Grownode is targeted for whoever has the need to build an automatic growing system, from DIY home growing to more advanced farming solutions. How GrowNode can help you This platform will facilitate the hardware and software design and implementation phase, by giving you a ready made set of functionalities, materials and knowledge base. Skills required In order to startup a basic prebuilt system, you just need to follow the instructions in boards section. If you want to play hard and develop your own customized system, a basic knowledge of C programming, ESP-IDF development environment, and electrical engineering is required. Examples Simple notification system You can use GrowNode to build a system that warns you when humidity and temperature on a plant is outside determined range, by blinking a LED: Network connected system You can then add network connectivity to a server and have your board warns you on your PC or mobile phone, and change the system parameters via a simple interface. Environment controlled system GrowNode has a growing list of supported sensors and actuators, in order to build a more sophisticated system. You can add sensors, motors, lights, pumps, everything needed to build your own solution customized to your needs. Distributed, orchestrated system Grownode is born having in mind IoT distributed environments. You can add nodes to your system and those nodes will easily talk between each other, acting as a unique orchestrated platform, with no limits over its scalability. Technologies GrowNode works with most common technologies, relying on minimal custom code in order to obtain the most reliable platform features, benefits from ESP32 core and open source development effort. It supports HOMIE protocol for autodiscovery and standard MQTT messaging","title":"Introduction"},{"location":"#abstract","text":"GrowNode is a vertical framework to build esp32 based devices targeted to growing plants in a controlled environment. It is currently based on the work of Nicola Muratori and Adamo Ferro .","title":"Abstract"},{"location":"#target","text":"Grownode is targeted for whoever has the need to build an automatic growing system, from DIY home growing to more advanced farming solutions.","title":"Target"},{"location":"#how-grownode-can-help-you","text":"This platform will facilitate the hardware and software design and implementation phase, by giving you a ready made set of functionalities, materials and knowledge base.","title":"How GrowNode can help you"},{"location":"#skills-required","text":"In order to startup a basic prebuilt system, you just need to follow the instructions in boards section. If you want to play hard and develop your own customized system, a basic knowledge of C programming, ESP-IDF development environment, and electrical engineering is required.","title":"Skills required"},{"location":"#examples","text":"","title":"Examples"},{"location":"#simple-notification-system","text":"You can use GrowNode to build a system that warns you when humidity and temperature on a plant is outside determined range, by blinking a LED:","title":"Simple notification system"},{"location":"#network-connected-system","text":"You can then add network connectivity to a server and have your board warns you on your PC or mobile phone, and change the system parameters via a simple interface.","title":"Network connected system"},{"location":"#environment-controlled-system","text":"GrowNode has a growing list of supported sensors and actuators, in order to build a more sophisticated system. You can add sensors, motors, lights, pumps, everything needed to build your own solution customized to your needs.","title":"Environment controlled system"},{"location":"#distributed-orchestrated-system","text":"Grownode is born having in mind IoT distributed environments. You can add nodes to your system and those nodes will easily talk between each other, acting as a unique orchestrated platform, with no limits over its scalability.","title":"Distributed, orchestrated system"},{"location":"#technologies","text":"GrowNode works with most common technologies, relying on minimal custom code in order to obtain the most reliable platform features, benefits from ESP32 core and open source development effort. It supports HOMIE protocol for autodiscovery and standard MQTT messaging","title":"Technologies"},{"location":"platform/","text":"A quick look into GrowNode systems This page describes how the GrowNode platform is structured and the technology behind it. Architecture A full GrowNode system architecture is composed by one or more grownode boards (called nodes) each board is connected to several sensors (called leaves) a messaging server where each board talks using MQTT an automation server - like openhab, home assistant - that orchestrate the node operations several clients to display and manage nodes other systems, like home automation, gardening, that works together with grownode Working tools GrowNode aims to use most common development tools. Actual release is composed by: Hardware ESP32 and above microcontrollers Common sensors and actuators (relay, PWM output, temperature probes, capacitance sensors..) with any esp-idf compatible libraries (optional) Various displays tested (ILI9341) with touch screen (tested XPT2046) capabilities (optional) A server like a raspberry to host the server side components in case you want to develop a network solution Software Components ESP-IDF (release 4.4) programming environment (optional) MQTT broker as a messaging system - if you want to exchange info between boards and servers (optional) LVGL as display library - if you want to attach a screen to display your sensor values (optional) OpenHab/Home Assistant as a controller Functionalities Grownode provides functionalities that lets you kickstart your projects in minutes: SoftAP/Bluetooth Provisioning to join and change your wireless network without any hardcode configuration through a mobile app High level device configuration through makefile Firmware update Over The Air NTP clock sync Persistent storage of parameters Sensor and Actuators configuration abstracting the hardware level Transparent networking protocol (presentation, keepalive, logging) Client/Server and Client/Client parameter retrieval and update through MQTT","title":"Platform"},{"location":"platform/#a-quick-look-into-grownode-systems","text":"This page describes how the GrowNode platform is structured and the technology behind it.","title":"A quick look into GrowNode systems"},{"location":"platform/#architecture","text":"A full GrowNode system architecture is composed by one or more grownode boards (called nodes) each board is connected to several sensors (called leaves) a messaging server where each board talks using MQTT an automation server - like openhab, home assistant - that orchestrate the node operations several clients to display and manage nodes other systems, like home automation, gardening, that works together with grownode","title":"Architecture"},{"location":"platform/#working-tools","text":"GrowNode aims to use most common development tools. Actual release is composed by:","title":"Working tools"},{"location":"platform/#hardware","text":"ESP32 and above microcontrollers Common sensors and actuators (relay, PWM output, temperature probes, capacitance sensors..) with any esp-idf compatible libraries (optional) Various displays tested (ILI9341) with touch screen (tested XPT2046) capabilities (optional) A server like a raspberry to host the server side components in case you want to develop a network solution","title":"Hardware"},{"location":"platform/#software-components","text":"ESP-IDF (release 4.4) programming environment (optional) MQTT broker as a messaging system - if you want to exchange info between boards and servers (optional) LVGL as display library - if you want to attach a screen to display your sensor values (optional) OpenHab/Home Assistant as a controller","title":"Software Components"},{"location":"platform/#functionalities","text":"Grownode provides functionalities that lets you kickstart your projects in minutes: SoftAP/Bluetooth Provisioning to join and change your wireless network without any hardcode configuration through a mobile app High level device configuration through makefile Firmware update Over The Air NTP clock sync Persistent storage of parameters Sensor and Actuators configuration abstracting the hardware level Transparent networking protocol (presentation, keepalive, logging) Client/Server and Client/Client parameter retrieval and update through MQTT","title":"Functionalities"},{"location":"start/","text":"Getting Started This page describes the steps needed to have a working development environment on your PC. For more detailed, platform - specific installation procedure including IDE, see section Tutorials Set up your environment ESP-IDF ESP-IDF is the development environment provided by the ESP32 chipmaker. It lets you design applications using the full chipset capabilities. I've decided to use it instead of higher level solutions like Arduino in order to achieve maximum flexibility and control. install ESP-IDF as per ESP-IDF getting started guide Note: actual grownode library is made over esp-idf release 4.4. make sure to download the appropriate version IDE Latest Windows ESP-IDF installations are including an Eclipse development environment that is already configured to run an ESP-IDF project. If you want to install your own IDE, prepare your favorite development environment (Anyway, I am personally using eclipse with ESP-IDF plugin . You should install the 'Eclipse for C/C++ developers'). Obtain GrowNode Open an IDF shell (in Windows you should find in in your Windows start menu - it is called ESP-IDF 4.4 CMD), change dir where you want to install grownode Note: if you have installed Eclipse, I recommend to start a new workspace, then open a shell to the workspace directory Clone GrowNode repository using GIT command git clone --recurse-submodules https://github.com/ogghst/grownode.git Note: if you have installed Eclipse, you can now import the project using Import projects... -> Espressif -> Existing IDF project and select the grownode directory created with git clone command Check everything works Via ESP-IDF command prompt Open an IDF shell (you should find it in your Windows start menu - it is called ESP-IDF 4.4 CMD), change dir where you have downloaded the grownode git folder, run idf.py build . It will compile for few minutes. Note: in Eclipse, select an esp32 target and build the grownode project If everything runs well, you should see something like Project build complete Plug your ESP32 into your USB port, take note of the COM port you are attached, and run idf.py -p (PORT) flash Note: Some boards requires a lower communication speed. In this case, you should use the command idf.py -p (PORT) -b 115200 flash Via Eclipse IDE Open Eclipse IDE Import the project you have downloaded using Project -> Import -> Existing IDF Project Press Ctrl+B to build the project If everything runs well, you should see something like Project build complete Plug your ESP32 into your USB port, create a new launch target with the COM port of the board, and run using Ctrl + F11 With default installation, you will see something like: ... I (0) cpu_start: App cpu up. I (141) cpu_start: Pro cpu start user code I (141) cpu_start: cpu freq: 160000000 I (141) cpu_start: Application information: I (146) cpu_start: Project name: grownode I (151) cpu_start: App version: v0.3.0-21-g3184a68-dirty I (157) cpu_start: Compile time: Jan 9 2022 08:53:43 I (163) cpu_start: ELF file SHA256: b0acca75d147e901... I (169) cpu_start: ESP-IDF: v4.4-beta1-275-g214d62b9ad I (176) heap_init: Initializing. RAM available for dynamic allocation: I (183) heap_init: At 3FFAE6E0 len 00001920 (6 KiB): DRAM I (189) heap_init: At 3FFB2D90 len 0002D270 (180 KiB): DRAM I (196) heap_init: At 3FFE0440 len 00003AE0 (14 KiB): D/IRAM I (202) heap_init: At 3FFE4350 len 0001BCB0 (111 KiB): D/IRAM I (208) heap_init: At 4008C058 len 00013FA8 (79 KiB): IRAM I (216) spi_flash: detected chip: generic I (219) spi_flash: flash io: dio I (224) cpu_start: Starting scheduler on PRO CPU. I (0) cpu_start: Starting scheduler on APP CPU. I (254) grownode: grownode startup sequence completed! I (264) grownode: _gn_start_leaf blink I (364) grownode: _gn_start_leaf blink completed I (5264) gn_blink: blinking - 0 I (10264) gn_blink: blinking - 1 ... Network Startup If you want to add network connectivity to your board, you need to input the wifi credentials into your board. This process is called provisioning. First you need to modify your sdkconfig file via the command idf.py menuconfig and select under Grownode component the enable networking checkbox. Then it's time to configure the network parameters. Modify the main.c file with your MQTT server address: gn_config_init_param_t config_init = { ... .server_url = \"mqtt://grownode\", ... }; Then you need to recompile and flash again the board to upload the firmware with network capabilities. Once the new firmware is uploadeed, you will see in the console: ... I (558) wifi:wifi driver task: 3ffc2d98, prio:23, stack:6656, core=0 I (558) system_api: Base MAC address is not set I (558) system_api: read default base MAC address from EFUSE I (568) wifi:wifi firmware version: 5c3d3bf I (568) wifi:wifi certification version: v7.0 I (568) wifi:config NVS flash: enabled I (568) wifi:config nano formating: disabled I (578) wifi:Init data frame dynamic rx buffer num: 32 I (578) wifi:Init management frame dynamic rx buffer num: 32 I (588) wifi:Init management short buffer num: 32 I (588) wifi:Init dynamic tx buffer num: 32 I (598) wifi:Init static rx buffer size: 1600 I (598) wifi:Init static rx buffer num: 10 I (598) wifi:Init dynamic rx buffer num: 32 I (608) wifi_init: rx ba win: 6 I (608) wifi_init: tcpip mbox: 32 I (618) wifi_init: udp mbox: 6 I (618) wifi_init: tcp mbox: 6 I (618) wifi_init: tcp tx win: 5744 I (628) wifi_init: tcp rx win: 5744 I (628) wifi_init: tcp mss: 1440 I (638) wifi_init: WiFi IRAM OP enabled I (638) wifi_init: WiFi RX IRAM OP enabled I (648) gn_network: Starting provisioning I (648) phy_init: phy_version 4670,719f9f6,Feb 18 2021,17:07:07 I (758) wifi:mode : sta (84:cc:a8:5e:60:48) I (758) wifi:enable tsf I (758) wifi:mode : sta (84:cc:a8:5e:60:48) + softAP (84:cc:a8:5e:60:49) I (768) wifi:Total power save buffer number: 16 I (768) wifi:Init max length of beacon: 752/752 I (768) wifi:Init max length of beacon: 752/752 I (778) wifi:Total power save buffer number: 16 W (778) wifi_prov_scheme_softap: Error adding mDNS service! Check if mDNS is running I (788) wifi_prov_mgr: Provisioning started with service name : GROWNODE_5E6048 I (788) gn_network: Provisioning Started ... Now, you need to download the app: Android: Google PlayStore iOS: Apple App Store Follow these steps on the Phone app: Click on \"Provision Device\" Click on the \"I don't have a QR code\" button. Tap on \"Connect\" and connect to your ESP32's SoftAP Process Select the wifi network that the board has temporarily created. As default this is GROWNODE_XXXX where XXXX is a subset of the board MAC address. The app will then show you the visible wifi network to the board, just select your network and put the password As proof of possession, default is 'grownode'. You can configure it in the 'main' application if the password is correct you will see this screen The board console will show something like: ... I (115448) gn_network: Provisioning OK I (116318) gn_network: Initializing SNTP. Using the SNTP server: pool.ntp.org I (116318) gn_mqtt_protocol: Connecting MQTT server at mqtt://grownode I (117368) gn_mqtt_protocol: MQTT client handshake successful I (117368) grownode: grownode startup sequence completed! I (117388) grownode: _gn_start_leaf blink I (117488) grownode: _gn_start_leaf blink completed I (122388) gn_blink: blinking - 1 I (127388) gn_blink: blinking - 0 I (132388) gn_blink: blinking - 1 ... That's it! You're online!","title":"Install"},{"location":"start/#getting-started","text":"This page describes the steps needed to have a working development environment on your PC. For more detailed, platform - specific installation procedure including IDE, see section Tutorials","title":"Getting Started"},{"location":"start/#set-up-your-environment","text":"","title":"Set up your environment"},{"location":"start/#esp-idf","text":"ESP-IDF is the development environment provided by the ESP32 chipmaker. It lets you design applications using the full chipset capabilities. I've decided to use it instead of higher level solutions like Arduino in order to achieve maximum flexibility and control. install ESP-IDF as per ESP-IDF getting started guide Note: actual grownode library is made over esp-idf release 4.4. make sure to download the appropriate version","title":"ESP-IDF"},{"location":"start/#ide","text":"Latest Windows ESP-IDF installations are including an Eclipse development environment that is already configured to run an ESP-IDF project. If you want to install your own IDE, prepare your favorite development environment (Anyway, I am personally using eclipse with ESP-IDF plugin . You should install the 'Eclipse for C/C++ developers').","title":"IDE"},{"location":"start/#obtain-grownode","text":"Open an IDF shell (in Windows you should find in in your Windows start menu - it is called ESP-IDF 4.4 CMD), change dir where you want to install grownode Note: if you have installed Eclipse, I recommend to start a new workspace, then open a shell to the workspace directory Clone GrowNode repository using GIT command git clone --recurse-submodules https://github.com/ogghst/grownode.git Note: if you have installed Eclipse, you can now import the project using Import projects... -> Espressif -> Existing IDF project and select the grownode directory created with git clone command","title":"Obtain GrowNode"},{"location":"start/#check-everything-works","text":"","title":"Check everything works"},{"location":"start/#via-esp-idf-command-prompt","text":"Open an IDF shell (you should find it in your Windows start menu - it is called ESP-IDF 4.4 CMD), change dir where you have downloaded the grownode git folder, run idf.py build . It will compile for few minutes. Note: in Eclipse, select an esp32 target and build the grownode project If everything runs well, you should see something like Project build complete Plug your ESP32 into your USB port, take note of the COM port you are attached, and run idf.py -p (PORT) flash Note: Some boards requires a lower communication speed. In this case, you should use the command idf.py -p (PORT) -b 115200 flash","title":"Via ESP-IDF command prompt"},{"location":"start/#via-eclipse-ide","text":"Open Eclipse IDE Import the project you have downloaded using Project -> Import -> Existing IDF Project Press Ctrl+B to build the project If everything runs well, you should see something like Project build complete Plug your ESP32 into your USB port, create a new launch target with the COM port of the board, and run using Ctrl + F11 With default installation, you will see something like: ... I (0) cpu_start: App cpu up. I (141) cpu_start: Pro cpu start user code I (141) cpu_start: cpu freq: 160000000 I (141) cpu_start: Application information: I (146) cpu_start: Project name: grownode I (151) cpu_start: App version: v0.3.0-21-g3184a68-dirty I (157) cpu_start: Compile time: Jan 9 2022 08:53:43 I (163) cpu_start: ELF file SHA256: b0acca75d147e901... I (169) cpu_start: ESP-IDF: v4.4-beta1-275-g214d62b9ad I (176) heap_init: Initializing. RAM available for dynamic allocation: I (183) heap_init: At 3FFAE6E0 len 00001920 (6 KiB): DRAM I (189) heap_init: At 3FFB2D90 len 0002D270 (180 KiB): DRAM I (196) heap_init: At 3FFE0440 len 00003AE0 (14 KiB): D/IRAM I (202) heap_init: At 3FFE4350 len 0001BCB0 (111 KiB): D/IRAM I (208) heap_init: At 4008C058 len 00013FA8 (79 KiB): IRAM I (216) spi_flash: detected chip: generic I (219) spi_flash: flash io: dio I (224) cpu_start: Starting scheduler on PRO CPU. I (0) cpu_start: Starting scheduler on APP CPU. I (254) grownode: grownode startup sequence completed! I (264) grownode: _gn_start_leaf blink I (364) grownode: _gn_start_leaf blink completed I (5264) gn_blink: blinking - 0 I (10264) gn_blink: blinking - 1 ...","title":"Via Eclipse IDE"},{"location":"start/#network-startup","text":"If you want to add network connectivity to your board, you need to input the wifi credentials into your board. This process is called provisioning. First you need to modify your sdkconfig file via the command idf.py menuconfig and select under Grownode component the enable networking checkbox. Then it's time to configure the network parameters. Modify the main.c file with your MQTT server address: gn_config_init_param_t config_init = { ... .server_url = \"mqtt://grownode\", ... }; Then you need to recompile and flash again the board to upload the firmware with network capabilities. Once the new firmware is uploadeed, you will see in the console: ... I (558) wifi:wifi driver task: 3ffc2d98, prio:23, stack:6656, core=0 I (558) system_api: Base MAC address is not set I (558) system_api: read default base MAC address from EFUSE I (568) wifi:wifi firmware version: 5c3d3bf I (568) wifi:wifi certification version: v7.0 I (568) wifi:config NVS flash: enabled I (568) wifi:config nano formating: disabled I (578) wifi:Init data frame dynamic rx buffer num: 32 I (578) wifi:Init management frame dynamic rx buffer num: 32 I (588) wifi:Init management short buffer num: 32 I (588) wifi:Init dynamic tx buffer num: 32 I (598) wifi:Init static rx buffer size: 1600 I (598) wifi:Init static rx buffer num: 10 I (598) wifi:Init dynamic rx buffer num: 32 I (608) wifi_init: rx ba win: 6 I (608) wifi_init: tcpip mbox: 32 I (618) wifi_init: udp mbox: 6 I (618) wifi_init: tcp mbox: 6 I (618) wifi_init: tcp tx win: 5744 I (628) wifi_init: tcp rx win: 5744 I (628) wifi_init: tcp mss: 1440 I (638) wifi_init: WiFi IRAM OP enabled I (638) wifi_init: WiFi RX IRAM OP enabled I (648) gn_network: Starting provisioning I (648) phy_init: phy_version 4670,719f9f6,Feb 18 2021,17:07:07 I (758) wifi:mode : sta (84:cc:a8:5e:60:48) I (758) wifi:enable tsf I (758) wifi:mode : sta (84:cc:a8:5e:60:48) + softAP (84:cc:a8:5e:60:49) I (768) wifi:Total power save buffer number: 16 I (768) wifi:Init max length of beacon: 752/752 I (768) wifi:Init max length of beacon: 752/752 I (778) wifi:Total power save buffer number: 16 W (778) wifi_prov_scheme_softap: Error adding mDNS service! Check if mDNS is running I (788) wifi_prov_mgr: Provisioning started with service name : GROWNODE_5E6048 I (788) gn_network: Provisioning Started ... Now, you need to download the app: Android: Google PlayStore iOS: Apple App Store Follow these steps on the Phone app: Click on \"Provision Device\" Click on the \"I don't have a QR code\" button. Tap on \"Connect\" and connect to your ESP32's SoftAP Process Select the wifi network that the board has temporarily created. As default this is GROWNODE_XXXX where XXXX is a subset of the board MAC address. The app will then show you the visible wifi network to the board, just select your network and put the password As proof of possession, default is 'grownode'. You can configure it in the 'main' application if the password is correct you will see this screen The board console will show something like: ... I (115448) gn_network: Provisioning OK I (116318) gn_network: Initializing SNTP. Using the SNTP server: pool.ntp.org I (116318) gn_mqtt_protocol: Connecting MQTT server at mqtt://grownode I (117368) gn_mqtt_protocol: MQTT client handshake successful I (117368) grownode: grownode startup sequence completed! I (117388) grownode: _gn_start_leaf blink I (117488) grownode: _gn_start_leaf blink completed I (122388) gn_blink: blinking - 1 I (127388) gn_blink: blinking - 0 I (132388) gn_blink: blinking - 1 ... That's it! You're online!","title":"Network Startup"},{"location":"story/","text":"How Everything Started It all started with an idea. We're now in an era where technology could help in restoring the connection between urban people, nature and food. Everyone can have access to resources that were available only to big industries until just 5 years ago. Microcontrollers and hardware components are now available for few dollars, 3D printers can make complex and specialized parts that were impossible to find on general market or hand craft. You can access online to all the information you need to build almost everything. And most of us lives in urban areas, we can buy food but we have no way to produce it. And if you can access to some land, you have no time to manage it. Therefore I started putting all pieces together. It's now possible to build systems capable of growing and harvesting your food at your home, with an home made system capable of automating growing parameters. And it's possible to build them at your home with tools you can buy easily. Lots of examples are available online by users who started their projects from scratch. And I'm a software engineer used to work with open source technologies. I know the added value that the community work has. My knowledge, the tools I use every day, and ultimately my salary is obtained thanks to people that decided to share their creative work to everyone. So maybe it's my turn to return what the community gave to me. First Steps, First Fails First steps in automating my plants growth were made using circuits using Arduino environment, custom code, recycled parts found in my house, wiring sensors and actuators by hand After some attempts, (almost) working projects, (many) dead plants and (some) successful harvesting, I've immediately found the limits in this methodology: Every time I needed to change the behavior of one component, or add a new feature, the entire project had to be revised The system has the need to interact with user, to inform over the his status (eg. temperature, water level), to ask for help (eg. board offline, no water) I needed to integrate the system in my existing home automation, to have an unique place where to check and operate over my plants Once my farming projects increases in number and quality, and my knowledge of this technology advances, I felt the need to add new features and correct bugs in old works In short, I needed a workshop to develop my projects with I started exploring the existing solution, starting from software tools, and found the most promising: Espressif Rainmaker - amazing project from ESP32 vendors to focus on custom application code inheriting a lot of prebuilt features - but too vendor-dependent for me: it requires a cloud connection and it is focused in automating well-defined, industrialized home appliance ESPHome - quick and easy way to build boards with almost zero code as an Home Assistant add-on - supereasy for very simple projects, but not scalable to develop complex devices and interactions After nights of web searches I realized the ugly truth - I needed something different, time to write it from scratch! The Idea The goals I wanted to reach were: Not just a software library, but a vertical platform Automating plant growing is not only a matter of writing code. You need to design the system, build it, wire everything together, and keep the environment suitable for your plants. Therefore, the project must contain not only code, but schematics, design documents, 3d prints.. An user will need to access and modify all of them. A potential community has to exchange not only new versions of a software library but also new DYI projects, recipes, sugestions. Lot of skills are involved and GrowNode will have to speak a lot of languages. Focus on system architecture, not functionalities Whoever has to work with this project, has to start with simple things. Custom code written has to be limited to defining what sensors are present in the system, and how they have to interact between each other. Schematics, 3D prints, instructions should be avaialable to give to users the physical building blocks that matches software components Decoupled, scalable system The environment where GrowNode systems has to operate will be distributed, scalable, etherogeneous. System boundaries can change as we increase the size of our farm, we add features, or entire new systems. A farming project could interact with his environment, e.g. opening a rollershutter to give the plants light. If you want to play hard, you can Simple systems should be ready in minutes, but you will find your own personal needs soon. Each plant has his own need. Every house or garden has his own climate. Technology advance at the speed of lights and every month there is something new to experiment. There's no one size fits all here. Users shall have the possibility to design their own components and architectures, and the GrowNode platform shall provide the access to the raw code and schematics when it's time to.","title":"Story"},{"location":"story/#how-everything-started","text":"It all started with an idea. We're now in an era where technology could help in restoring the connection between urban people, nature and food. Everyone can have access to resources that were available only to big industries until just 5 years ago. Microcontrollers and hardware components are now available for few dollars, 3D printers can make complex and specialized parts that were impossible to find on general market or hand craft. You can access online to all the information you need to build almost everything. And most of us lives in urban areas, we can buy food but we have no way to produce it. And if you can access to some land, you have no time to manage it. Therefore I started putting all pieces together. It's now possible to build systems capable of growing and harvesting your food at your home, with an home made system capable of automating growing parameters. And it's possible to build them at your home with tools you can buy easily. Lots of examples are available online by users who started their projects from scratch. And I'm a software engineer used to work with open source technologies. I know the added value that the community work has. My knowledge, the tools I use every day, and ultimately my salary is obtained thanks to people that decided to share their creative work to everyone. So maybe it's my turn to return what the community gave to me.","title":"How Everything Started"},{"location":"story/#first-steps-first-fails","text":"First steps in automating my plants growth were made using circuits using Arduino environment, custom code, recycled parts found in my house, wiring sensors and actuators by hand After some attempts, (almost) working projects, (many) dead plants and (some) successful harvesting, I've immediately found the limits in this methodology: Every time I needed to change the behavior of one component, or add a new feature, the entire project had to be revised The system has the need to interact with user, to inform over the his status (eg. temperature, water level), to ask for help (eg. board offline, no water) I needed to integrate the system in my existing home automation, to have an unique place where to check and operate over my plants Once my farming projects increases in number and quality, and my knowledge of this technology advances, I felt the need to add new features and correct bugs in old works In short, I needed a workshop to develop my projects with I started exploring the existing solution, starting from software tools, and found the most promising: Espressif Rainmaker - amazing project from ESP32 vendors to focus on custom application code inheriting a lot of prebuilt features - but too vendor-dependent for me: it requires a cloud connection and it is focused in automating well-defined, industrialized home appliance ESPHome - quick and easy way to build boards with almost zero code as an Home Assistant add-on - supereasy for very simple projects, but not scalable to develop complex devices and interactions After nights of web searches I realized the ugly truth - I needed something different, time to write it from scratch!","title":"First Steps, First Fails"},{"location":"story/#the-idea","text":"The goals I wanted to reach were:","title":"The Idea"},{"location":"story/#not-just-a-software-library-but-a-vertical-platform","text":"Automating plant growing is not only a matter of writing code. You need to design the system, build it, wire everything together, and keep the environment suitable for your plants. Therefore, the project must contain not only code, but schematics, design documents, 3d prints.. An user will need to access and modify all of them. A potential community has to exchange not only new versions of a software library but also new DYI projects, recipes, sugestions. Lot of skills are involved and GrowNode will have to speak a lot of languages.","title":"Not just a software library, but a vertical platform"},{"location":"story/#focus-on-system-architecture-not-functionalities","text":"Whoever has to work with this project, has to start with simple things. Custom code written has to be limited to defining what sensors are present in the system, and how they have to interact between each other. Schematics, 3D prints, instructions should be avaialable to give to users the physical building blocks that matches software components","title":"Focus on system architecture, not functionalities"},{"location":"story/#decoupled-scalable-system","text":"The environment where GrowNode systems has to operate will be distributed, scalable, etherogeneous. System boundaries can change as we increase the size of our farm, we add features, or entire new systems. A farming project could interact with his environment, e.g. opening a rollershutter to give the plants light.","title":"Decoupled, scalable system"},{"location":"story/#if-you-want-to-play-hard-you-can","text":"Simple systems should be ready in minutes, but you will find your own personal needs soon. Each plant has his own need. Every house or garden has his own climate. Technology advance at the speed of lights and every month there is something new to experiment. There's no one size fits all here. Users shall have the possibility to design their own components and architectures, and the GrowNode platform shall provide the access to the raw code and schematics when it's time to.","title":"If you want to play hard, you can"},{"location":"workflow/","text":"From Ideas to Project This page aims to give you the basics on the necessary steps to define and design a GrowNode system. If you are already an advanced user.. You're welcome to add your experience! :) Design your application Define the scope of your project The first step into your journey in a GrowNode implementation is like every other automated farming project: you need to understand what type of system you want to implement. - what do you want to grow? from lettuce to strawberries, to herbs, each situation has his own needs and techniques - where you want to grow? from a greenhouse to a pot into your kitchen, the environment is important and has effects on the design - how you want to grow? You want a fully automated system? Or just a light that is turning some hours per day? Choose among the several possible techniques, and what you want to measure and control. Use some tutorials if you are a newbie, like this one from YouTube. Sketch your system architecture Next step is to define the sensor involved in the system you are designing. You want to perform automatic watering? Then you need a water pump. You want to measure water temperature? Then you need a temperature probe. Help yourself with a conceptual schema or visit the solutions page already made with GrowNode (now it's just my home project :) ) Create your board You can now start getting your hands dirty!. But not yet in the soil. Your spades and hoes are now called CAD, PCB and solder. In this step you will transform your idea in working hardware. Wiring diagram First step is to attach all your sensors and actuators to the ESP32. Follow the datasheets, identify the needed hardware, connect to ESP32 GPIOs, put everything together in a schematic, that could be from a piece of paper to an advanced CAD. Depending on the type of outcome you want, you need to choose carefully your tool. - Prototyping - your target is probably a breadboard, therefore you should focus only on material needed, then you will wire up all together on the fly - Pre Production - you will probably create a PCB using online shops or directly at home and solder components by yourself - Production - you will design everything with a CAD, identify SMT components, and send everything to a PCB manufacturer like JLCPCB If you are unfamiliar with this process, visit the solutions page with some prebuilt ideas. Bill of Material Now you're ready to shop! List your devices you've included in the schematic and wait for the courier. Design your Software This is a process that can be done together with the hardware part described before. This is usually the most complex part, and this is where GrowNode will help you ! Configure your project Follow the instructions on Install page in order to have a working environment on your PC. After it, you have a preconfigured environment, that has to be personalized for your needs. You have two files to start: sdkconfig , in the main project directory. This is where all the instructions to the compiler resides. This is a standard place to put your settings that will enable specific functionalities. You can edit this file using the IDF command idf.py menuconfig in your IDF command shell. browse into component config , you will find a section named grownode : Some basic configuration parameters: reset flash at every startup : every time the board is started up, all information stored are wiped out. This is useful when you are testing the board and you want to restart every time with a clean situation. please note that this removes also your provisioning status (wifi SSID and password) enable networking : in order to have all the network related functionalities. in case of local boards or issues with firmware size this will reduce a lot the firware footprint and enhance performances. Dependant parameters are: provisioning transport : how the board will receive wifi credentials at startup. SoftAP means by becoming a local access point, Bluetooth is the other option. Depending on the choice, you will have to use one of the Espressif provisioning apps (at this page)[https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/provisioning/provisioning.html] SoftAP Prefix : the name of the temporary network the board will create to ask for wifi credentials Enable Display : if set, it will start the display driver. the configuration of the display will be taken from LVGL component configuration settings. Note: if you enable display, make sure in cmakelists.txt you have enabled the build of LVGL uncommenting the line set(ENV{LVGL_PATH} \"lvgl/lvgl lvgl/lvgl_esp32_drivers\") Code your application In the main folder of the project you will find a main.c file. This is the entry point of the application. Understanding the code requires a knowledge of the C language and it is not the goal of this tutorial. Here is a standard main application workflow walkthrough: Define log configuration directives Done by using the ESP-IDF logging system. Every GrowNode subsystem has his own log tag so it's easy to enable different logging levels depending on what you want to track. esp_log_level_set(\"*\", ESP_LOG_INFO); esp_log_level_set(\"grownode\", ESP_LOG_DEBUG); esp_log_level_set(\"gn_commons\", ESP_LOG_INFO); esp_log_level_set(\"gn_nvs\", ESP_LOG_INFO); ... Configure the application parameters Here the basic code block in a standard wifi configuration: gn_config_init_param_t config_init = { .provisioning_security = true, .provisioning_password = \"grownode\", .server_board_id_topic = false, .server_base_topic = \"/grownode\", .server_url = \"mqtt://mymqttserver.com\", .server_keepalive_timer_sec = 60, .firmware_url = \"http://myserver/grownode.bin\", .sntp_url = \"pool.ntp.org\" }; Here's the explanation of those parameters provisioning_security : whether provisioning data shall be encrypted and if yes the use of a proof of possession (password) is required. See esp-idf provisioning manual for details provisioning_password : the proof of possession password you will need to enter in the provisioning mobile app to let the board enter in your wifi network server_url : where to find the MQTT messaging server server_base_topic : the 'address' of the MQTT messages created by the board and the server server_board_id_topic : whether the board shall publish to the MQTT server its unique ID (calculated from MAC address). if true, the topic will be /grownode/ADBC1234 where 'abcd1234' is your board unique ID server_keepalive_timer_sec : how often the board shall publish a keepalive message see API firmare_url : where to search for an updated firmware when the OTA process will start sntp_url : the address of the time server the board will use to sync its clock Obtain the GrowNode configuration handle This starts the various subsystems like networking, server messaging, provisioning, display, depending on the configuration you choose in previous steps. gn_config_handle_t config = gn_init(config_init); Wait for the configuration to be completed It takes several seconds depending on the actions needed. In this area you can add your custom code that catches the configuration process status while (gn_get_config_status(config) != GN_CONFIG_STATUS_COMPLETED) { vTaskDelay(1000 / portTICK_PERIOD_MS); ESP_LOGI(TAG, \"grownode startup sequence code: %d\", gn_get_config_status(config)); } Create the Node Once the GrowNode configuration process has ended, you can then start defining your project structure. First step is to obtain a Node handler. This can be seen as the 'tree trunk' where the 'leaves' will be attached. gn_node_config_handle_t node = gn_node_create(config, \"node\"); Add leaves And then you can add your sensors and actuators, that in GrowNode languages are called leaves . Standard leaves code is contained on components/grownode/leaves folder gn_leaf_config_handle_t lights1in = gn_leaf_create(node, \"lights1in\", gn_relay_config, 4096); In this example we have created an handle to a relay leaf, called lights1in , using the config callback gn_relay_config , with a memory space of 4K. Every leaf has his own characteristic and purposes. Some represents sensors, some actuators, and some has the only purpose to implement control logic for other leaves. The relay leaf, for instance, can be reused for multiple actuators in multiple pins. Some others may have limitations due to the specific hardware used. In order to make a leaf usable you probably have to configure it. The relay leaf need to know what is the GPIO pin attached and the initial status: gn_leaf_param_init_double(lights1in, GN_RELAY_PARAM_GPIO, 25); gn_leaf_param_init_bool(lights1in, GN_RELAY_PARAM_STATUS, false); Some paramaters are stored in the board non volatile storage (NVS) for later use (both ones in this case), so the real effect of this initialization is just on the first board initialization. Once the parameters has been stored in the board, it is ignored. Please look at the header file of the leaf you want to use to understand the needed parameters. Start the node At this point the leaf is ready for the startup. This is made by calling: gn_node_start(node); The framework will tell the network that the board is online, publish the board sensor data, start all the leaves callbacks , start the listeners for leaves dialogue (in the relay leaf, this means the relay can be controlled by setting the status parameter). ...And do nothing forever! Last step, you should implement an infinite loop: while (true) { vTaskDelay(10000 / portTICK_PERIOD_MS); } Prebuilt leaves You can use the prebuilt leaves under leaves or browsing the github components/grownode/leaves folder. Every leaf has his own header file you can use to understand how to use it. Basic leaves as per today: Actuators Relay: turns on/off a GPIO Pump: uses the low frequency PWM API to drive a motor Pump_HS: uses the LEDC API to drive a PWM device, like dimming a LED or driving a motor Sensors: Capacitive Water Level: gives you the value of a touch sensing device, here used to detect water level Capacitive Moisture Sensor: gives you the value of the water level through an external moisture sensor BME280: gets the data from this temperature/humidity/pressure sensor DS18B20: gets the temperature of multiple temperature sensors connected to a GPIO Controllers: Pump Control: DEMO leaf to drive a pump depending on temperature Watering Control: A more sophisticated controller to drive a water tower hydroponic system, like hydroboard1 Create your own leaves Goal of GrowNode project is to embrace a wide number of technologies and growing techniques. So I've designed it to be expandable. You can code your own leaf by taking inspiration of the preexisting leaves. Please return to the open source community what the community gave to you, by including your work in this project. Wire it up Start putting your components in a breadbord according to your schematic. Make sure to test all possible hardware and software situation prior to pass to a more elaborated PCB. Share you work! Repeating myself once again. Once your board is working, please share to the community. Look at the preexisting boards, prepare your material, and let me know how you want to collaborate with GrowNode ecosystem.","title":"Play"},{"location":"workflow/#from-ideas-to-project","text":"This page aims to give you the basics on the necessary steps to define and design a GrowNode system. If you are already an advanced user.. You're welcome to add your experience! :)","title":"From Ideas to Project"},{"location":"workflow/#design-your-application","text":"","title":"Design your application"},{"location":"workflow/#define-the-scope-of-your-project","text":"The first step into your journey in a GrowNode implementation is like every other automated farming project: you need to understand what type of system you want to implement. - what do you want to grow? from lettuce to strawberries, to herbs, each situation has his own needs and techniques - where you want to grow? from a greenhouse to a pot into your kitchen, the environment is important and has effects on the design - how you want to grow? You want a fully automated system? Or just a light that is turning some hours per day? Choose among the several possible techniques, and what you want to measure and control. Use some tutorials if you are a newbie, like this one from YouTube.","title":"Define the scope of your project"},{"location":"workflow/#sketch-your-system-architecture","text":"Next step is to define the sensor involved in the system you are designing. You want to perform automatic watering? Then you need a water pump. You want to measure water temperature? Then you need a temperature probe. Help yourself with a conceptual schema or visit the solutions page already made with GrowNode (now it's just my home project :) )","title":"Sketch your system architecture"},{"location":"workflow/#create-your-board","text":"You can now start getting your hands dirty!. But not yet in the soil. Your spades and hoes are now called CAD, PCB and solder. In this step you will transform your idea in working hardware.","title":"Create your board"},{"location":"workflow/#wiring-diagram","text":"First step is to attach all your sensors and actuators to the ESP32. Follow the datasheets, identify the needed hardware, connect to ESP32 GPIOs, put everything together in a schematic, that could be from a piece of paper to an advanced CAD. Depending on the type of outcome you want, you need to choose carefully your tool. - Prototyping - your target is probably a breadboard, therefore you should focus only on material needed, then you will wire up all together on the fly - Pre Production - you will probably create a PCB using online shops or directly at home and solder components by yourself - Production - you will design everything with a CAD, identify SMT components, and send everything to a PCB manufacturer like JLCPCB If you are unfamiliar with this process, visit the solutions page with some prebuilt ideas.","title":"Wiring diagram"},{"location":"workflow/#bill-of-material","text":"Now you're ready to shop! List your devices you've included in the schematic and wait for the courier.","title":"Bill of Material"},{"location":"workflow/#design-your-software","text":"This is a process that can be done together with the hardware part described before. This is usually the most complex part, and this is where GrowNode will help you !","title":"Design your Software"},{"location":"workflow/#configure-your-project","text":"Follow the instructions on Install page in order to have a working environment on your PC. After it, you have a preconfigured environment, that has to be personalized for your needs. You have two files to start: sdkconfig , in the main project directory. This is where all the instructions to the compiler resides. This is a standard place to put your settings that will enable specific functionalities. You can edit this file using the IDF command idf.py menuconfig in your IDF command shell. browse into component config , you will find a section named grownode : Some basic configuration parameters: reset flash at every startup : every time the board is started up, all information stored are wiped out. This is useful when you are testing the board and you want to restart every time with a clean situation. please note that this removes also your provisioning status (wifi SSID and password) enable networking : in order to have all the network related functionalities. in case of local boards or issues with firmware size this will reduce a lot the firware footprint and enhance performances. Dependant parameters are: provisioning transport : how the board will receive wifi credentials at startup. SoftAP means by becoming a local access point, Bluetooth is the other option. Depending on the choice, you will have to use one of the Espressif provisioning apps (at this page)[https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/provisioning/provisioning.html] SoftAP Prefix : the name of the temporary network the board will create to ask for wifi credentials Enable Display : if set, it will start the display driver. the configuration of the display will be taken from LVGL component configuration settings. Note: if you enable display, make sure in cmakelists.txt you have enabled the build of LVGL uncommenting the line set(ENV{LVGL_PATH} \"lvgl/lvgl lvgl/lvgl_esp32_drivers\")","title":"Configure your project"},{"location":"workflow/#code-your-application","text":"In the main folder of the project you will find a main.c file. This is the entry point of the application. Understanding the code requires a knowledge of the C language and it is not the goal of this tutorial. Here is a standard main application workflow walkthrough:","title":"Code your application"},{"location":"workflow/#define-log-configuration-directives","text":"Done by using the ESP-IDF logging system. Every GrowNode subsystem has his own log tag so it's easy to enable different logging levels depending on what you want to track. esp_log_level_set(\"*\", ESP_LOG_INFO); esp_log_level_set(\"grownode\", ESP_LOG_DEBUG); esp_log_level_set(\"gn_commons\", ESP_LOG_INFO); esp_log_level_set(\"gn_nvs\", ESP_LOG_INFO); ...","title":"Define log configuration directives"},{"location":"workflow/#configure-the-application-parameters","text":"Here the basic code block in a standard wifi configuration: gn_config_init_param_t config_init = { .provisioning_security = true, .provisioning_password = \"grownode\", .server_board_id_topic = false, .server_base_topic = \"/grownode\", .server_url = \"mqtt://mymqttserver.com\", .server_keepalive_timer_sec = 60, .firmware_url = \"http://myserver/grownode.bin\", .sntp_url = \"pool.ntp.org\" }; Here's the explanation of those parameters provisioning_security : whether provisioning data shall be encrypted and if yes the use of a proof of possession (password) is required. See esp-idf provisioning manual for details provisioning_password : the proof of possession password you will need to enter in the provisioning mobile app to let the board enter in your wifi network server_url : where to find the MQTT messaging server server_base_topic : the 'address' of the MQTT messages created by the board and the server server_board_id_topic : whether the board shall publish to the MQTT server its unique ID (calculated from MAC address). if true, the topic will be /grownode/ADBC1234 where 'abcd1234' is your board unique ID server_keepalive_timer_sec : how often the board shall publish a keepalive message see API firmare_url : where to search for an updated firmware when the OTA process will start sntp_url : the address of the time server the board will use to sync its clock","title":"Configure the application parameters"},{"location":"workflow/#obtain-the-grownode-configuration-handle","text":"This starts the various subsystems like networking, server messaging, provisioning, display, depending on the configuration you choose in previous steps. gn_config_handle_t config = gn_init(config_init);","title":"Obtain the GrowNode configuration handle"},{"location":"workflow/#wait-for-the-configuration-to-be-completed","text":"It takes several seconds depending on the actions needed. In this area you can add your custom code that catches the configuration process status while (gn_get_config_status(config) != GN_CONFIG_STATUS_COMPLETED) { vTaskDelay(1000 / portTICK_PERIOD_MS); ESP_LOGI(TAG, \"grownode startup sequence code: %d\", gn_get_config_status(config)); }","title":"Wait for the configuration to be completed"},{"location":"workflow/#create-the-node","text":"Once the GrowNode configuration process has ended, you can then start defining your project structure. First step is to obtain a Node handler. This can be seen as the 'tree trunk' where the 'leaves' will be attached. gn_node_config_handle_t node = gn_node_create(config, \"node\");","title":"Create the Node"},{"location":"workflow/#add-leaves","text":"And then you can add your sensors and actuators, that in GrowNode languages are called leaves . Standard leaves code is contained on components/grownode/leaves folder gn_leaf_config_handle_t lights1in = gn_leaf_create(node, \"lights1in\", gn_relay_config, 4096); In this example we have created an handle to a relay leaf, called lights1in , using the config callback gn_relay_config , with a memory space of 4K. Every leaf has his own characteristic and purposes. Some represents sensors, some actuators, and some has the only purpose to implement control logic for other leaves. The relay leaf, for instance, can be reused for multiple actuators in multiple pins. Some others may have limitations due to the specific hardware used. In order to make a leaf usable you probably have to configure it. The relay leaf need to know what is the GPIO pin attached and the initial status: gn_leaf_param_init_double(lights1in, GN_RELAY_PARAM_GPIO, 25); gn_leaf_param_init_bool(lights1in, GN_RELAY_PARAM_STATUS, false); Some paramaters are stored in the board non volatile storage (NVS) for later use (both ones in this case), so the real effect of this initialization is just on the first board initialization. Once the parameters has been stored in the board, it is ignored. Please look at the header file of the leaf you want to use to understand the needed parameters.","title":"Add leaves"},{"location":"workflow/#start-the-node","text":"At this point the leaf is ready for the startup. This is made by calling: gn_node_start(node); The framework will tell the network that the board is online, publish the board sensor data, start all the leaves callbacks , start the listeners for leaves dialogue (in the relay leaf, this means the relay can be controlled by setting the status parameter).","title":"Start the node"},{"location":"workflow/#and-do-nothing-forever","text":"Last step, you should implement an infinite loop: while (true) { vTaskDelay(10000 / portTICK_PERIOD_MS); }","title":"...And do nothing forever!"},{"location":"workflow/#prebuilt-leaves","text":"You can use the prebuilt leaves under leaves or browsing the github components/grownode/leaves folder. Every leaf has his own header file you can use to understand how to use it. Basic leaves as per today:","title":"Prebuilt leaves"},{"location":"workflow/#actuators","text":"Relay: turns on/off a GPIO Pump: uses the low frequency PWM API to drive a motor Pump_HS: uses the LEDC API to drive a PWM device, like dimming a LED or driving a motor","title":"Actuators"},{"location":"workflow/#sensors","text":"Capacitive Water Level: gives you the value of a touch sensing device, here used to detect water level Capacitive Moisture Sensor: gives you the value of the water level through an external moisture sensor BME280: gets the data from this temperature/humidity/pressure sensor DS18B20: gets the temperature of multiple temperature sensors connected to a GPIO","title":"Sensors:"},{"location":"workflow/#controllers","text":"Pump Control: DEMO leaf to drive a pump depending on temperature Watering Control: A more sophisticated controller to drive a water tower hydroponic system, like hydroboard1","title":"Controllers:"},{"location":"workflow/#create-your-own-leaves","text":"Goal of GrowNode project is to embrace a wide number of technologies and growing techniques. So I've designed it to be expandable. You can code your own leaf by taking inspiration of the preexisting leaves. Please return to the open source community what the community gave to you, by including your work in this project.","title":"Create your own leaves"},{"location":"workflow/#wire-it-up","text":"Start putting your components in a breadbord according to your schematic. Make sure to test all possible hardware and software situation prior to pass to a more elaborated PCB.","title":"Wire it up"},{"location":"workflow/#share-you-work","text":"Repeating myself once again. Once your board is working, please share to the community. Look at the preexisting boards, prepare your material, and let me know how you want to collaborate with GrowNode ecosystem.","title":"Share you work!"},{"location":"boards/","text":"Boards Here you can find resources to make your own board starting from existing works. Code is in 'components\\grownode\\boards' folder Blink This is just a test board. Scope is to have your development board LED blinking to show you've done a great job :) Easypot1 A good starting point to make sure your pot won't suffer due to lack of attention :) Goal of this board is to introduce you to GrowNode platform, using super common components you can buy online. Board Detail Hydroboard1 This is the first project done using GrowNode platform. It is basically a Water Tower with water reservoir temperature control (heating/cooling) done through a Peltier cell, and a water level measurement device done by a capacitance sensor. Board Detail Hydroboard2 Second attempt to release a Water Tower system. this time I've added some MOSFETs to drive: 4 12VDC PWM output (I personally used for water pump, peltier pump, peltier fan, environmental fan 4 12VDC Relay output (Lights 1, Lights2, Peltier cell Hot and Cold mode) 2 temperature sensors (using DB18B20) 1 temperature/humidity/pressure sensor (using BME280) 1 capacitive water level sensor It has an onboard logic to keep the reservoir at desired temperature prior to water it (thus keeping the system on an acceptable temperature range through all the year) the board is powered with 220V - 12V 10A power adaptor so it can manage quite a lot of power consumption Board Detail Oscilloscope This is a board dedicated to measure current and power of a circuit using INA219, capable of transferring information to a Telegraf instance or via MQTT. I did it to probe other board power consumption in battery powered mode. Board Detail","title":"Boards"},{"location":"boards/#boards","text":"Here you can find resources to make your own board starting from existing works. Code is in 'components\\grownode\\boards' folder","title":"Boards"},{"location":"boards/#blink","text":"This is just a test board. Scope is to have your development board LED blinking to show you've done a great job :)","title":"Blink"},{"location":"boards/#easypot1","text":"A good starting point to make sure your pot won't suffer due to lack of attention :) Goal of this board is to introduce you to GrowNode platform, using super common components you can buy online. Board Detail","title":"Easypot1"},{"location":"boards/#hydroboard1","text":"This is the first project done using GrowNode platform. It is basically a Water Tower with water reservoir temperature control (heating/cooling) done through a Peltier cell, and a water level measurement device done by a capacitance sensor. Board Detail","title":"Hydroboard1"},{"location":"boards/#hydroboard2","text":"Second attempt to release a Water Tower system. this time I've added some MOSFETs to drive: 4 12VDC PWM output (I personally used for water pump, peltier pump, peltier fan, environmental fan 4 12VDC Relay output (Lights 1, Lights2, Peltier cell Hot and Cold mode) 2 temperature sensors (using DB18B20) 1 temperature/humidity/pressure sensor (using BME280) 1 capacitive water level sensor It has an onboard logic to keep the reservoir at desired temperature prior to water it (thus keeping the system on an acceptable temperature range through all the year) the board is powered with 220V - 12V 10A power adaptor so it can manage quite a lot of power consumption Board Detail","title":"Hydroboard2"},{"location":"boards/#oscilloscope","text":"This is a board dedicated to measure current and power of a circuit using INA219, capable of transferring information to a Telegraf instance or via MQTT. I did it to probe other board power consumption in battery powered mode. Board Detail","title":"Oscilloscope"},{"location":"boards/boards_easypot1/","text":"EasyPot1 A good starting point to make sure your pot won't suffer due to lack of attention :) Goal of this board is to introduce you to GrowNode platform, using super common components you can buy online. Features Soil moisture level detection with configurable low/high treshold Temperature detection Access to online tracking system to track your growing progress The board is equipped with LED showing the need to water your plant, excess light and temperature out of target. They will start to blink fast when the parameters are exceeding a treshold, and low when getting lower than this. Bill of Material 1 capacitive moisture level sensor 1 temperature sensor LED resistors breadboard and wires Assembling Wire your ESP32 to breadboard GND and 3V3 Wire your DS18B20 to GND, 3V3 and GPIO0 through a 4K7ohm resistor Wire your moisture sensor to GND, 3V3 and GPIO12 Wire your blue (moisture) LED to GND and GPIO1 (also called TX0) through a 100ohm resistor Wire your red (temperature) LED to GND and GPIO2 through a 100ohm resistor final configuration will look like: Code The configuration code, other than main\\main.c is contained in components\\grownode\\boards\\easypot1.c . The code is meant to be basic in order to give you some training to basic features. The Main You just need to 'load' the board into the firmware add an include \"easypot1.h\" directive on the header declarations change the configuration row from the standard gn_configure_blink(node) to gn_configure_easypot1(node) This will tell the compiler to load the easypot1 code into the firmware upon the next build. The Board On top of easypot1.c you have some configuration parameters: ... //sets the tresholds const double moist_min = 1; const double moist_max = 3; const double temp_min = 15; const double temp_max = 28; ... Those are setting the tresholds where the board shall start warning you with LED blinking There is also the possibility to configure the blinking time in msec ... //milliseconds to blink for low and high values const double blink_time_high = 300; const double blink_time_low = 2000; ... Controlling the pot If you enable networking, you will start receiving MQTT messages to your broker. For a detailed explanation, see Reference Guide . What you can do is - Receive updates over moisture and temperature sensors - Monitor LED statuses - Enable/disable the sensor updates - Manually turn on/off LEDs","title":"EasyPot1"},{"location":"boards/boards_easypot1/#easypot1","text":"A good starting point to make sure your pot won't suffer due to lack of attention :) Goal of this board is to introduce you to GrowNode platform, using super common components you can buy online.","title":"EasyPot1"},{"location":"boards/boards_easypot1/#features","text":"Soil moisture level detection with configurable low/high treshold Temperature detection Access to online tracking system to track your growing progress The board is equipped with LED showing the need to water your plant, excess light and temperature out of target. They will start to blink fast when the parameters are exceeding a treshold, and low when getting lower than this.","title":"Features"},{"location":"boards/boards_easypot1/#bill-of-material","text":"1 capacitive moisture level sensor 1 temperature sensor LED resistors breadboard and wires","title":"Bill of Material"},{"location":"boards/boards_easypot1/#assembling","text":"Wire your ESP32 to breadboard GND and 3V3 Wire your DS18B20 to GND, 3V3 and GPIO0 through a 4K7ohm resistor Wire your moisture sensor to GND, 3V3 and GPIO12 Wire your blue (moisture) LED to GND and GPIO1 (also called TX0) through a 100ohm resistor Wire your red (temperature) LED to GND and GPIO2 through a 100ohm resistor final configuration will look like:","title":"Assembling"},{"location":"boards/boards_easypot1/#code","text":"The configuration code, other than main\\main.c is contained in components\\grownode\\boards\\easypot1.c . The code is meant to be basic in order to give you some training to basic features.","title":"Code"},{"location":"boards/boards_easypot1/#the-main","text":"You just need to 'load' the board into the firmware add an include \"easypot1.h\" directive on the header declarations change the configuration row from the standard gn_configure_blink(node) to gn_configure_easypot1(node) This will tell the compiler to load the easypot1 code into the firmware upon the next build.","title":"The Main"},{"location":"boards/boards_easypot1/#the-board","text":"On top of easypot1.c you have some configuration parameters: ... //sets the tresholds const double moist_min = 1; const double moist_max = 3; const double temp_min = 15; const double temp_max = 28; ... Those are setting the tresholds where the board shall start warning you with LED blinking There is also the possibility to configure the blinking time in msec ... //milliseconds to blink for low and high values const double blink_time_high = 300; const double blink_time_low = 2000; ...","title":"The Board"},{"location":"boards/boards_easypot1/#controlling-the-pot","text":"If you enable networking, you will start receiving MQTT messages to your broker. For a detailed explanation, see Reference Guide . What you can do is - Receive updates over moisture and temperature sensors - Monitor LED statuses - Enable/disable the sensor updates - Manually turn on/off LEDs","title":"Controlling the pot"},{"location":"boards/boards_hb1/","text":"Hydroboard1 This is the first project done using GrowNode platform. It is basically a Water Tower with water reservoir temperature control (heating/cooling) done through a Peltier cell, and a water level measurement device done by a capacitance sensor. Here is the code to startup all the leaves: gn_leaf_config_handle_t lights1in = gn_leaf_create(node, \"lights1in\", gn_relay_config, 4096); gn_leaf_param_init_double(lights1in, GN_RELAY_PARAM_GPIO, 25); gn_leaf_param_init_bool(lights1in, GN_RELAY_PARAM_STATUS, false); gn_leaf_config_handle_t lights2in = gn_leaf_create(node, \"lights2in\", gn_relay_config, 4096); gn_leaf_param_init_double(lights2in, GN_RELAY_PARAM_GPIO, 5); gn_leaf_param_init_bool(lights2in, GN_RELAY_PARAM_STATUS, false); gn_leaf_config_handle_t plt_a = gn_leaf_create(node, \"plt_a\", gn_relay_config, 4096); gn_leaf_param_init_double(plt_a, GN_RELAY_PARAM_GPIO, 23); gn_leaf_param_init_bool(plt_a, GN_RELAY_PARAM_STATUS, false); gn_leaf_config_handle_t plt_b = gn_leaf_create(node, \"plt_b\", gn_relay_config, 4096); gn_leaf_param_init_double(plt_b, GN_RELAY_PARAM_GPIO, 17); gn_leaf_param_init_bool(plt_b, GN_RELAY_PARAM_STATUS, false); gn_leaf_config_handle_t waterpumpin = gn_leaf_create(node, \"waterpumpin\", gn_relay_config, 4096); gn_leaf_param_init_double(waterpumpin, GN_RELAY_PARAM_GPIO, 19); gn_leaf_param_init_bool(waterpumpin, GN_RELAY_PARAM_STATUS, false); gn_leaf_config_handle_t waterlevelin = gn_leaf_create(node, \"waterlevelin\", gn_capacitive_water_level_config, 4096); gn_leaf_param_init_bool(waterlevelin, GN_CWL_PARAM_ACTIVE, true); gn_leaf_param_init_double(waterlevelin, GN_CWL_PARAM_TOUCH_CHANNEL, 2); gn_leaf_param_init_double(waterlevelin, GN_CWL_PARAM_UPDATE_TIME_SEC, 10); gn_leaf_param_init_double(waterlevelin, GN_CWL_PARAM_MIN_LEVEL, 0); gn_leaf_param_init_double(waterlevelin, GN_CWL_PARAM_MAX_LEVEL, 2048); gn_leaf_config_handle_t hcc_speed = gn_leaf_create(node, \"hcc\", gn_pump_hs_config, 4096); gn_leaf_param_init_bool(hcc_speed, GN_PUMP_HS_PARAM_CHANNEL, 0); gn_leaf_param_init_double(hcc_speed, GN_PUMP_HS_PARAM_GPIO_POWER, 18); gn_leaf_param_init_double(hcc_speed, GN_PUMP_HS_PARAM_POWER, 0); gn_leaf_param_init_double(hcc_speed, GN_PUMP_HS_PARAM_GPIO_TOGGLE, 26); gn_leaf_param_init_bool(hcc_speed, GN_PUMP_HS_PARAM_TOGGLE, false); gn_leaf_config_handle_t fan_speed = gn_leaf_create(node, \"fan\", gn_pump_hs_config, 4096); gn_leaf_param_init_bool(fan_speed, GN_PUMP_HS_PARAM_CHANNEL, 1); gn_leaf_param_init_double(fan_speed, GN_PUMP_HS_PARAM_GPIO_POWER, 27); gn_leaf_param_init_double(fan_speed, GN_PUMP_HS_PARAM_POWER, 0); gn_leaf_param_init_double(fan_speed, GN_PUMP_HS_PARAM_GPIO_TOGGLE, 33); gn_leaf_param_init_bool(fan_speed, GN_PUMP_HS_PARAM_TOGGLE, false); gn_leaf_config_handle_t bme280 = gn_leaf_create(node, \"bme280\", gn_bme280_config, 8192); gn_leaf_param_init_double(bme280, GN_BME280_PARAM_SDA, 21); gn_leaf_param_init_double(bme280, GN_BME280_PARAM_SCL, 22); gn_leaf_param_init_bool(bme280, GN_BME280_PARAM_ACTIVE, true); gn_leaf_param_init_double(bme280, GN_BME280_PARAM_UPDATE_TIME_SEC, 10); gn_leaf_config_handle_t ds18b20 = gn_leaf_create(node, \"ds18b20\", gn_ds18b20_config, 4096); gn_leaf_param_init_double(ds18b20, GN_DS18B20_PARAM_GPIO, 4); gn_leaf_param_init_bool(ds18b20, GN_DS18B20_PARAM_ACTIVE, true); gn_leaf_param_init_double(ds18b20, GN_DS18B20_PARAM_UPDATE_TIME_SEC, 5); gn_leaf_config_handle_t watering_control = gn_leaf_create(node, \"watering_control\", gn_watering_control_config, 4096); gn_leaf_param_init_double(watering_control, GN_WAT_CTR_PARAM_WATERING_INTERVAL_SEC, 60 * 1); gn_leaf_param_init_double(watering_control, GN_WAT_CTR_PARAM_WATERING_TIME_SEC, 20); gn_leaf_param_init_double(watering_control, GN_WAT_CTR_PARAM_WATERING_TARGET_TEMP, 20); gn_leaf_param_init_bool(watering_control, GN_WAT_CTR_PARAM_ACTIVE, true); The working logic is onboard, represented by the leaf gn_watering_control . Basically it keeps the reservoir at a controlled temperature and starts the watering periodically if the water is within admissible range. MQTT Messaging is then collected by a page in OpenHAB where I can display the status of the components. I've done a first schematic: And a first prototype board: Then i've built a 3D case: And wired up all together in a demo station: Now i wanted now to move in a more stable circuit, here is the new schematic: And you can see a draft of the 3D layout:","title":"HydroBoard1"},{"location":"boards/boards_hb1/#hydroboard1","text":"This is the first project done using GrowNode platform. It is basically a Water Tower with water reservoir temperature control (heating/cooling) done through a Peltier cell, and a water level measurement device done by a capacitance sensor. Here is the code to startup all the leaves: gn_leaf_config_handle_t lights1in = gn_leaf_create(node, \"lights1in\", gn_relay_config, 4096); gn_leaf_param_init_double(lights1in, GN_RELAY_PARAM_GPIO, 25); gn_leaf_param_init_bool(lights1in, GN_RELAY_PARAM_STATUS, false); gn_leaf_config_handle_t lights2in = gn_leaf_create(node, \"lights2in\", gn_relay_config, 4096); gn_leaf_param_init_double(lights2in, GN_RELAY_PARAM_GPIO, 5); gn_leaf_param_init_bool(lights2in, GN_RELAY_PARAM_STATUS, false); gn_leaf_config_handle_t plt_a = gn_leaf_create(node, \"plt_a\", gn_relay_config, 4096); gn_leaf_param_init_double(plt_a, GN_RELAY_PARAM_GPIO, 23); gn_leaf_param_init_bool(plt_a, GN_RELAY_PARAM_STATUS, false); gn_leaf_config_handle_t plt_b = gn_leaf_create(node, \"plt_b\", gn_relay_config, 4096); gn_leaf_param_init_double(plt_b, GN_RELAY_PARAM_GPIO, 17); gn_leaf_param_init_bool(plt_b, GN_RELAY_PARAM_STATUS, false); gn_leaf_config_handle_t waterpumpin = gn_leaf_create(node, \"waterpumpin\", gn_relay_config, 4096); gn_leaf_param_init_double(waterpumpin, GN_RELAY_PARAM_GPIO, 19); gn_leaf_param_init_bool(waterpumpin, GN_RELAY_PARAM_STATUS, false); gn_leaf_config_handle_t waterlevelin = gn_leaf_create(node, \"waterlevelin\", gn_capacitive_water_level_config, 4096); gn_leaf_param_init_bool(waterlevelin, GN_CWL_PARAM_ACTIVE, true); gn_leaf_param_init_double(waterlevelin, GN_CWL_PARAM_TOUCH_CHANNEL, 2); gn_leaf_param_init_double(waterlevelin, GN_CWL_PARAM_UPDATE_TIME_SEC, 10); gn_leaf_param_init_double(waterlevelin, GN_CWL_PARAM_MIN_LEVEL, 0); gn_leaf_param_init_double(waterlevelin, GN_CWL_PARAM_MAX_LEVEL, 2048); gn_leaf_config_handle_t hcc_speed = gn_leaf_create(node, \"hcc\", gn_pump_hs_config, 4096); gn_leaf_param_init_bool(hcc_speed, GN_PUMP_HS_PARAM_CHANNEL, 0); gn_leaf_param_init_double(hcc_speed, GN_PUMP_HS_PARAM_GPIO_POWER, 18); gn_leaf_param_init_double(hcc_speed, GN_PUMP_HS_PARAM_POWER, 0); gn_leaf_param_init_double(hcc_speed, GN_PUMP_HS_PARAM_GPIO_TOGGLE, 26); gn_leaf_param_init_bool(hcc_speed, GN_PUMP_HS_PARAM_TOGGLE, false); gn_leaf_config_handle_t fan_speed = gn_leaf_create(node, \"fan\", gn_pump_hs_config, 4096); gn_leaf_param_init_bool(fan_speed, GN_PUMP_HS_PARAM_CHANNEL, 1); gn_leaf_param_init_double(fan_speed, GN_PUMP_HS_PARAM_GPIO_POWER, 27); gn_leaf_param_init_double(fan_speed, GN_PUMP_HS_PARAM_POWER, 0); gn_leaf_param_init_double(fan_speed, GN_PUMP_HS_PARAM_GPIO_TOGGLE, 33); gn_leaf_param_init_bool(fan_speed, GN_PUMP_HS_PARAM_TOGGLE, false); gn_leaf_config_handle_t bme280 = gn_leaf_create(node, \"bme280\", gn_bme280_config, 8192); gn_leaf_param_init_double(bme280, GN_BME280_PARAM_SDA, 21); gn_leaf_param_init_double(bme280, GN_BME280_PARAM_SCL, 22); gn_leaf_param_init_bool(bme280, GN_BME280_PARAM_ACTIVE, true); gn_leaf_param_init_double(bme280, GN_BME280_PARAM_UPDATE_TIME_SEC, 10); gn_leaf_config_handle_t ds18b20 = gn_leaf_create(node, \"ds18b20\", gn_ds18b20_config, 4096); gn_leaf_param_init_double(ds18b20, GN_DS18B20_PARAM_GPIO, 4); gn_leaf_param_init_bool(ds18b20, GN_DS18B20_PARAM_ACTIVE, true); gn_leaf_param_init_double(ds18b20, GN_DS18B20_PARAM_UPDATE_TIME_SEC, 5); gn_leaf_config_handle_t watering_control = gn_leaf_create(node, \"watering_control\", gn_watering_control_config, 4096); gn_leaf_param_init_double(watering_control, GN_WAT_CTR_PARAM_WATERING_INTERVAL_SEC, 60 * 1); gn_leaf_param_init_double(watering_control, GN_WAT_CTR_PARAM_WATERING_TIME_SEC, 20); gn_leaf_param_init_double(watering_control, GN_WAT_CTR_PARAM_WATERING_TARGET_TEMP, 20); gn_leaf_param_init_bool(watering_control, GN_WAT_CTR_PARAM_ACTIVE, true); The working logic is onboard, represented by the leaf gn_watering_control . Basically it keeps the reservoir at a controlled temperature and starts the watering periodically if the water is within admissible range. MQTT Messaging is then collected by a page in OpenHAB where I can display the status of the components. I've done a first schematic: And a first prototype board: Then i've built a 3D case: And wired up all together in a demo station: Now i wanted now to move in a more stable circuit, here is the new schematic: And you can see a draft of the 3D layout:","title":"Hydroboard1"},{"location":"boards/boards_hb2/","text":"Hydroboard2 Second attempt to release a Water Tower system. this time I've added some MOSFETs to drive: Features 4 12VDC PWM output (I personally used them for water pump, peltier pump, peltier fan, environmental fan) 4 12VDC Relay output (Lights 1, Lights2, Peltier cell Hot and Cold mode) 2 temperature sensors (using DB18B20) 1 temperature/humidity/pressure sensor (using BME280) 1 capacitive water level sensor It has an onboard logic to keep the reservoir at desired temperature prior to water it (thus keeping the system on an acceptable temperature range through all the year) The board is powered with 220V - 12V 10A power adaptor so it can manage quite a lot of power consumption. Code The configuration code is contained in components\\grownode\\boards\\bydroboard2.c . The working logic is onboard, represented by the leaf components\\grownode\\leaves\\gn_hydroboard2_watering_control . Basically it keeps the reservoir at a controlled temperature and starts the watering periodically if the water is within admissible range. MQTT Messaging is then collected by a page in OpenHAB where I can display the status of the components: EASYEDA Project: link The first prototype board: Here's the beautiful IKEA case :)","title":"HydroBoard2"},{"location":"boards/boards_hb2/#hydroboard2","text":"Second attempt to release a Water Tower system. this time I've added some MOSFETs to drive:","title":"Hydroboard2"},{"location":"boards/boards_hb2/#features","text":"4 12VDC PWM output (I personally used them for water pump, peltier pump, peltier fan, environmental fan) 4 12VDC Relay output (Lights 1, Lights2, Peltier cell Hot and Cold mode) 2 temperature sensors (using DB18B20) 1 temperature/humidity/pressure sensor (using BME280) 1 capacitive water level sensor It has an onboard logic to keep the reservoir at desired temperature prior to water it (thus keeping the system on an acceptable temperature range through all the year) The board is powered with 220V - 12V 10A power adaptor so it can manage quite a lot of power consumption.","title":"Features"},{"location":"boards/boards_hb2/#code","text":"The configuration code is contained in components\\grownode\\boards\\bydroboard2.c . The working logic is onboard, represented by the leaf components\\grownode\\leaves\\gn_hydroboard2_watering_control . Basically it keeps the reservoir at a controlled temperature and starts the watering periodically if the water is within admissible range. MQTT Messaging is then collected by a page in OpenHAB where I can display the status of the components: EASYEDA Project: link The first prototype board: Here's the beautiful IKEA case :)","title":"Code"},{"location":"boards/boards_oscilloscope/","text":"Oscilloscope This is a board dedicated to measure current and power of a circuit using INA219, capable of transferring information to a Telegraf instance or via MQTT. I did it to probe other board power consumption in battery powered mode. Features Measuring current, voltage, power Configurable sampling interval Configurable number of samples to average per interval Capable of transfer information to other reporting system via UDP using telegraf/influxdb Measurement Voltage 0V...26V Max Current 3.2A Max Power 83W Operation Voltage 3V...5.5V Communication Protocol I2C Bill of Material 1 INA219 breakout board breadboard and wires Assembling Wire your ESP32 to breadboard GND and 3V3 Wire your INA219 as per the table ESP32 INA219 GND GND 5V VCC 27 SCL 26 SDA Wire your load to be measured to VIN+ and VIN- as per the figure Code The configuration code, other than main\\main.c is contained in components\\grownode\\boards\\oscilloscope.c . The code is meant to be basic in order to give you some training to basic features. The Main You just need to 'load' the board into the firmware add an include \"oscilloscope.h\" directive on the header declarations change the configuration row from the standard gn_configure_blink(node) to gn_configure_oscilloscope(node) This will tell the compiler to load the easypot1 code into the firmware upon the next build. Playing with code See the INA219 leaf reference doc to understand how to configure and play with parameters Creating a full monitoring system TODO Final Result Here's a quick demo I did while testing:","title":"Boards oscilloscope"},{"location":"boards/boards_oscilloscope/#oscilloscope","text":"This is a board dedicated to measure current and power of a circuit using INA219, capable of transferring information to a Telegraf instance or via MQTT. I did it to probe other board power consumption in battery powered mode.","title":"Oscilloscope"},{"location":"boards/boards_oscilloscope/#features","text":"Measuring current, voltage, power Configurable sampling interval Configurable number of samples to average per interval Capable of transfer information to other reporting system via UDP using telegraf/influxdb Measurement Voltage 0V...26V Max Current 3.2A Max Power 83W Operation Voltage 3V...5.5V Communication Protocol I2C","title":"Features"},{"location":"boards/boards_oscilloscope/#bill-of-material","text":"1 INA219 breakout board breadboard and wires","title":"Bill of Material"},{"location":"boards/boards_oscilloscope/#assembling","text":"Wire your ESP32 to breadboard GND and 3V3 Wire your INA219 as per the table ESP32 INA219 GND GND 5V VCC 27 SCL 26 SDA Wire your load to be measured to VIN+ and VIN- as per the figure","title":"Assembling"},{"location":"boards/boards_oscilloscope/#code","text":"The configuration code, other than main\\main.c is contained in components\\grownode\\boards\\oscilloscope.c . The code is meant to be basic in order to give you some training to basic features.","title":"Code"},{"location":"boards/boards_oscilloscope/#the-main","text":"You just need to 'load' the board into the firmware add an include \"oscilloscope.h\" directive on the header declarations change the configuration row from the standard gn_configure_blink(node) to gn_configure_oscilloscope(node) This will tell the compiler to load the easypot1 code into the firmware upon the next build.","title":"The Main"},{"location":"boards/boards_oscilloscope/#playing-with-code","text":"See the INA219 leaf reference doc to understand how to configure and play with parameters","title":"Playing with code"},{"location":"boards/boards_oscilloscope/#creating-a-full-monitoring-system","text":"TODO","title":"Creating a full monitoring system"},{"location":"boards/boards_oscilloscope/#final-result","text":"Here's a quick demo I did while testing:","title":"Final Result"},{"location":"reference/","text":"Reference Guide This page aims to describe the GrowNode API and how to use it to develop your own firmware. Disclaimer: This is NOT intended for ready-made solution users. Don't tell me I've not warned you! :) GrowNode is based on the ESP32 microprocessor, and is developed on top of the ESP-IDF Development Framework. This allows one to directly access to the ESP32 functionalities and the real-time operating system (RTOS). In order to mantain a coherent code style and ease the access of all ESP-IDF functionalities, GrowNode is written in pure C, although a C++ version could be done in next future. Basic Concepts The highest level structure on a GrowNode system is the board itself. Every solution you want to build is basically a combination of: Devices attached to the IO pins (typically handled by specific HAL - Hardware Abstraction Layers - like ESP-IDF core libraries or third party devices). Examples: I2C driver, a GPIO pin Several logics to access to those devices, which are called Leaves in the GrowNode framework - several are prebuilt and more can be user defined. Examples: a temperature sensor, a relay, a LED, a motor Several Parameters exposed by/to the Leaf, able to retrieve/command specific functionalities. Examples: the temperature retrieved, a motor switch, a light power One centralized controller that exposes to the Leaves the services needed to work, called Node . This is common on all the GrowNode implementations one entry point of the application, where the Node and Leaves are declared and configured, called Board . Examples: a Water Tower Board, a simple Temperature and Humidity pot controller Architecture In ESP-IDF vocabulary, the Board and its corresponding Node works in the main application RTOS task, and each Leaf works in a separate task. This allows the parallel execution of task logic and, moreover, avoids that a leaf in waiting state (eg. waiting for a sensor measure) affects the running of the whole Node. All messaging across leaves is implemented through RTOS events and message queues. Putting all together, here's an overview of GrowNode platform: Code reference Code Documentation is described in API section. The entry point of all GrowNode functionalities resides in the grownode.h header file. Users just have to reference it in their code.","title":"Reference Guide"},{"location":"reference/#reference-guide","text":"This page aims to describe the GrowNode API and how to use it to develop your own firmware. Disclaimer: This is NOT intended for ready-made solution users. Don't tell me I've not warned you! :) GrowNode is based on the ESP32 microprocessor, and is developed on top of the ESP-IDF Development Framework. This allows one to directly access to the ESP32 functionalities and the real-time operating system (RTOS). In order to mantain a coherent code style and ease the access of all ESP-IDF functionalities, GrowNode is written in pure C, although a C++ version could be done in next future.","title":"Reference Guide"},{"location":"reference/#basic-concepts","text":"The highest level structure on a GrowNode system is the board itself. Every solution you want to build is basically a combination of: Devices attached to the IO pins (typically handled by specific HAL - Hardware Abstraction Layers - like ESP-IDF core libraries or third party devices). Examples: I2C driver, a GPIO pin Several logics to access to those devices, which are called Leaves in the GrowNode framework - several are prebuilt and more can be user defined. Examples: a temperature sensor, a relay, a LED, a motor Several Parameters exposed by/to the Leaf, able to retrieve/command specific functionalities. Examples: the temperature retrieved, a motor switch, a light power One centralized controller that exposes to the Leaves the services needed to work, called Node . This is common on all the GrowNode implementations one entry point of the application, where the Node and Leaves are declared and configured, called Board . Examples: a Water Tower Board, a simple Temperature and Humidity pot controller","title":"Basic Concepts"},{"location":"reference/#architecture","text":"In ESP-IDF vocabulary, the Board and its corresponding Node works in the main application RTOS task, and each Leaf works in a separate task. This allows the parallel execution of task logic and, moreover, avoids that a leaf in waiting state (eg. waiting for a sensor measure) affects the running of the whole Node. All messaging across leaves is implemented through RTOS events and message queues. Putting all together, here's an overview of GrowNode platform:","title":"Architecture"},{"location":"reference/#code-reference","text":"Code Documentation is described in API section. The entry point of all GrowNode functionalities resides in the grownode.h header file. Users just have to reference it in their code.","title":"Code reference"},{"location":"reference/boards/","text":"Boards Boards are a collection of preconfigured Leaves to have a ready made solution, described in Boards section. Goal is to give you a working solution without the need of develop your own code. In order to include a board in your code, you just need to modify your main.c file including the appropriate header file in components/grownode/boards library folder and call the appropriate board configuration function: ... //header include the board you want to start here #include \"gn_blink.h\" ... //creates a new node gn_node_handle_t node = gn_node_create(config, \"node\"); //the board to start gn_configure_blink(node); //finally, start node gn_node_start(node);","title":"Boards"},{"location":"reference/boards/#boards","text":"Boards are a collection of preconfigured Leaves to have a ready made solution, described in Boards section. Goal is to give you a working solution without the need of develop your own code. In order to include a board in your code, you just need to modify your main.c file including the appropriate header file in components/grownode/boards library folder and call the appropriate board configuration function: ... //header include the board you want to start here #include \"gn_blink.h\" ... //creates a new node gn_node_handle_t node = gn_node_create(config, \"node\"); //the board to start gn_configure_blink(node); //finally, start node gn_node_start(node);","title":"Boards"},{"location":"reference/build_system/","text":"Build System Grownode relies on ESP-IDF build system. It is designed to be a component, and you can configure the build options via standard ESP-IDF command line or from your IDE. See Configuration section.","title":"Build System"},{"location":"reference/build_system/#build-system","text":"Grownode relies on ESP-IDF build system. It is designed to be a component, and you can configure the build options via standard ESP-IDF command line or from your IDE. See Configuration section.","title":"Build System"},{"location":"reference/display/","text":"Display todo","title":"Display"},{"location":"reference/display/#display","text":"todo","title":"Display"},{"location":"reference/error/","text":"Error handling GrowNode relies on ESP-IDF error handling API to handle errors. GrowNode specific error codes are handled via the gn_err_t enum. All platform functions are returning this enum to let the user handle the situation appropriately.","title":"Error"},{"location":"reference/error/#error-handling","text":"GrowNode relies on ESP-IDF error handling API to handle errors. GrowNode specific error codes are handled via the gn_err_t enum. All platform functions are returning this enum to let the user handle the situation appropriately.","title":"Error handling"},{"location":"reference/events/","text":"Event subsystem Main application works in a RTOS task. Leaves works in dedicated tasks. Networking and other ESP-IDF services has their own tasks as well. This means that all communication through those components must be done using the RTOS task messaging features and higher ESP-IDF abstractions. GrowNode uses Event Loop library from ESP-IDF to list, subscribe and publish events. It declares one base event GN_BASE_EVENT and a gn_event_id_t enumeration where all event types are listed. Subscribing events In order to grab a specific event you can rely on ESP-IDF event loop functions. In order to recall the proper event loop from a Leaf or Node, gn_leaf_get_event_loop() and gn_node_get_event_loop() are provided. See example: //register for events esp_event_handler_instance_register_with(gn_leaf_get_event_loop(leaf_config), GN_BASE_EVENT, GN_EVENT_ANY_ID, gn_leaf_led_status_event_handler, leaf_config, NULL); This code creates a subscription for all events ( GN_EVENT_ANY_ID ), calling gn_leaf_led_status_event_handler callback once an event is triggered, and pass the leaf_config pointer in the context. Those functions returns currently the same event loop, different implementations are made for future needs. Publishing events Event are published using straight esp event loop functionalities: esp_event_post_to(event_loop, GN_BASE_EVENT, GN_NET_CONNECTED_EVENT, NULL, 0, portMAX_DELAY); Listening for event Event callbacks shall implement esp_event_handler_t syntax. Payload is dependent on the event type triggered: void gn_pump_control_task_event_handler(void *handler_args, esp_event_base_t base, int32_t event_id, void *event_data) { gn_leaf_parameter_event_t *evt = (gn_leaf_parameter_event_t*) event_data; switch (event_id) { case GN_LEAF_PARAM_CHANGED_EVENT: ... Acquiring events in leaf code Events addressed to leaves from other leaves and from network has a special, direct way to be processed, that improves GrowNode engine performances, using RTOS queues. Leaves that has just to wait for an event can implement an infinite loop where an xQueueReceive() function waits for events for a specific time window. If no events are presents in the queue, the queue releases the control to the leaf: gn_leaf_parameter_event_t evt; if (xQueueReceive(gn_leaf_get_event_queue(leaf_config), &evt, pdMS_TO_TICKS(100)) == pdPASS) { //event arrived for this node switch (evt.id) { //parameter change case GN_LEAF_PARAM_CHANGE_REQUEST_EVENT: ESP_LOGD(TAG, \"request to update param %s, data = '%s'\", evt.param_name, evt.data); ...","title":"Event subsystem"},{"location":"reference/events/#event-subsystem","text":"Main application works in a RTOS task. Leaves works in dedicated tasks. Networking and other ESP-IDF services has their own tasks as well. This means that all communication through those components must be done using the RTOS task messaging features and higher ESP-IDF abstractions. GrowNode uses Event Loop library from ESP-IDF to list, subscribe and publish events. It declares one base event GN_BASE_EVENT and a gn_event_id_t enumeration where all event types are listed.","title":"Event subsystem"},{"location":"reference/events/#subscribing-events","text":"In order to grab a specific event you can rely on ESP-IDF event loop functions. In order to recall the proper event loop from a Leaf or Node, gn_leaf_get_event_loop() and gn_node_get_event_loop() are provided. See example: //register for events esp_event_handler_instance_register_with(gn_leaf_get_event_loop(leaf_config), GN_BASE_EVENT, GN_EVENT_ANY_ID, gn_leaf_led_status_event_handler, leaf_config, NULL); This code creates a subscription for all events ( GN_EVENT_ANY_ID ), calling gn_leaf_led_status_event_handler callback once an event is triggered, and pass the leaf_config pointer in the context. Those functions returns currently the same event loop, different implementations are made for future needs.","title":"Subscribing events"},{"location":"reference/events/#publishing-events","text":"Event are published using straight esp event loop functionalities: esp_event_post_to(event_loop, GN_BASE_EVENT, GN_NET_CONNECTED_EVENT, NULL, 0, portMAX_DELAY);","title":"Publishing events"},{"location":"reference/events/#listening-for-event","text":"Event callbacks shall implement esp_event_handler_t syntax. Payload is dependent on the event type triggered: void gn_pump_control_task_event_handler(void *handler_args, esp_event_base_t base, int32_t event_id, void *event_data) { gn_leaf_parameter_event_t *evt = (gn_leaf_parameter_event_t*) event_data; switch (event_id) { case GN_LEAF_PARAM_CHANGED_EVENT: ...","title":"Listening for event"},{"location":"reference/events/#acquiring-events-in-leaf-code","text":"Events addressed to leaves from other leaves and from network has a special, direct way to be processed, that improves GrowNode engine performances, using RTOS queues. Leaves that has just to wait for an event can implement an infinite loop where an xQueueReceive() function waits for events for a specific time window. If no events are presents in the queue, the queue releases the control to the leaf: gn_leaf_parameter_event_t evt; if (xQueueReceive(gn_leaf_get_event_queue(leaf_config), &evt, pdMS_TO_TICKS(100)) == pdPASS) { //event arrived for this node switch (evt.id) { //parameter change case GN_LEAF_PARAM_CHANGE_REQUEST_EVENT: ESP_LOGD(TAG, \"request to update param %s, data = '%s'\", evt.param_name, evt.data); ...","title":"Acquiring events in leaf code"},{"location":"reference/leaves/","text":"Leaves Every sensor or actuator is represented by a Leaf. The Leaf is the connection of the underlying hardware, it is designed to be reusable multiple times in a Node and to be configured in a consistent way. A Leaf represents the bridge between the User and the hardware layer, therefore it is handled by the GrowNode engine as a separated RTOS task, and is accessed in an asyncronous way. Using Leaves Every leaf shall expose a gn_leaf_config_callback callback function that initializes its resources. In order to add a leaf to a node, the gn_leaf_create function is called first: gn_leaf_handle_t gn_leaf_create(gn_node_handle_t node, const char *name, gn_leaf_config_callback leaf_config, size_t task_size) This binds the Leaf to the parent Node, and tells the Node to use the gn_leaf_config_callback callback to initialize the resources at the appropriate moment. Typical job of a config callback function is to load and initialize its parameters and allocate memory for the side structures. Callback definition is: typedef gn_leaf_descriptor_handle_t (*gn_leaf_config_callback)( gn_leaf_handle_t leaf_config); The gn_leaf_descriptor_handle_t is a reference to the information configured. GrowNode engine will use later those info to start the leaf. Another callback must be implemented in the leaf: typedef void (*gn_leaf_task_callback)(gn_leaf_handle_t leaf_config); In this callback it is contained the business logic of the leaf, like: reading the Leaf parameter status listening for parameter updates from external sources (network or internal) updating the user UI working with underlying hardware resources updating its parameters Examples //creates the moisture sensor moisture_leaf = gn_leaf_create(node, \"moisture\", gn_capacitive_moisture_sensor_config, 4096); User defined Leaves This section aims to give you necessary knowledge over the Leaves management framework. Is intended for users that want to use preconfigured leaves or to build new leaves. It's a rather simple task and many working examples are present in the leaves folder. A Leaf is tipycally used to bridge the hardware layer, supported by a collection of Parameters that represents the inputs and outputs of its operations. A Leaf can also be used to coordinate other leaves by sending messages and modifying their parameters. In order to approach to this topic, you must understand the parameter API features. Parameter declaration The declaration of a parameter inside a Leaf is done by calling gn_leaf_param_create() . Signature: gn_leaf_param_handle_t gn_leaf_param_create(gn_leaf_handle_t leaf_config, const char *name, const gn_val_type_t type, const gn_val_t val, gn_leaf_param_access_type_t access, gn_leaf_param_storage_t storage, gn_validator_callback_t validator); The return type of this function is a reference to the parameter, that will be stored into the leaf for future use. Parameter Types Parameters are strong typed. That means that internally into Grownode engine they are represented using C types. Types are enumerated in gn_val_type_t . typedef enum { GN_VAL_TYPE_STRING, /*!< character array, user defined dimension */ GN_VAL_TYPE_BOOLEAN, /*!< true/false */ GN_VAL_TYPE_DOUBLE, /*!< floating point with sign */ } gn_val_type_t; Storage of the value is made by an union called gn_val_t : typedef union { char *s; bool b; double d; } gn_val_t; As you can see from this definition, it is user responsibility to allocate memory in case of a char array parameter. This has to be done inside the Leaf code. Access Type Parameters can have multiple uses, and therefore its access type can be different: typedef enum { GN_LEAF_PARAM_ACCESS_ALL = 0x01, /*!< param can be modified both by the node and network (eg. local configuration settings)*/ GN_LEAF_PARAM_ACCESS_NETWORK = 0x02, /*!< param can be modified only by network (eg. configuration settings from environment)*/ GN_LEAF_PARAM_ACCESS_NODE = 0x03, /*!< param can be modified only by the node (eg. sensor data)*/ GN_LEAF_PARAM_ACCESS_NODE_INTERNAL = 0x04 /*!< param can be modified only by the node (eg. sensor data) and it is not shown externally*/ } gn_leaf_param_access_type_t; The access type is evaluated upon parameter change. If the request is not compatible with the access type (eg. a network request against a GN_LEAF_PARAM_ACCESS_NODE access type) the request won't have any effect. Storage Some parameters holds the board hardware configuration, like the GPIO pin a sensor is attached to, or board status information that neeed to survive over board restarts or power failures (like the standard power a pump shall be activated). Those parameters can be stored on each update in the ESP32 Non Volatile Storage (NVS). The current implementation stores in key-value pairs, before hashing the key using leaf name and parameter name. typedef enum { GN_LEAF_PARAM_STORAGE_PERSISTED, /*!< param is stored in NVS flash every time it changes*/ GN_LEAF_PARAM_STORAGE_VOLATILE /*< param is never stored in NVS flash*/ } gn_leaf_param_storage_t; Pay attention to not persist parameters that have continuous updates, like temperature. It can cause a fast degradation of the board memory! Validators Making sure the parameter update arriving from the network makes sense can be a boring task for a leaf developer. And risk of forgetting a check and allow unsafe values can break the code or even make the system dangerous (think of turning on a pump at exceeding speed or without a time limit). For this reason, the Grownode platform exposes a reusable mechanism to make the code safer: parameter validators. Validators are functions compliant to the gn_validator_callback_t callback: typedef gn_leaf_param_validator_result_t (*gn_validator_callback_t)( gn_leaf_param_handle_t param, void **value); The intended behavior is to check the value agains predetermined values, and return the result code on its gn_leaf_param_validator_result_t variable: typedef enum { GN_LEAF_PARAM_VALIDATOR_PASSED = 0x000, /*!< value is compliant */ GN_LEAF_PARAM_VALIDATOR_ERROR_ABOVE_MAX = 0x001, /*!< value is over the maximum limit */ GN_LEAF_PARAM_VALIDATOR_ERROR_BELOW_MIN = 0x002, /*!< value is below the minimum limit */ GN_LEAF_PARAM_VALIDATOR_ERROR_NOT_ALLOWED = 0x100, /*!< value is not allowed for other reasons */ GN_LEAF_PARAM_VALIDATOR_ERROR_GENERIC = 0x101, /*!< algorithm has returned an error */ GN_LEAF_PARAM_VALIDATOR_PASSED_CHANGED = 0x200 /*!< value was not allowed but has been modified by the validator to be compliant*/ } gn_leaf_param_validator_result_t; As you can see, there is a possibility that the validator changes the value of the parameter, like if the value to be checked is below zero then set the value to zero. Standard validators are present for standard value types: gn_leaf_param_validator_result_t gn_validator_double_positive( gn_leaf_param_handle_t param, void **param_value); gn_leaf_param_validator_result_t gn_validator_double( gn_leaf_param_handle_t param, void **param_value); gn_leaf_param_validator_result_t gn_validator_boolean( gn_leaf_param_handle_t param, void **param_value); But it's easy to add new ones. Examples can be found in gn_hydroboard2_watering_control.c code: gn_leaf_param_validator_result_t _gn_hb2_watering_time_validator( gn_leaf_param_handle_t param, void **param_value) { double val; if (gn_leaf_param_get_value(param, &val) != GN_RET_OK) return GN_LEAF_PARAM_VALIDATOR_ERROR; double _p1 = **(double**) param_value; ESP_LOGD(TAG, \"_watering_time_validator - param: %d\", (int )_p1); if (GN_HYDROBOARD2_MIN_WATERING_TIME > **(double**) param_value) { memcpy(param_value, &GN_HYDROBOARD2_MIN_WATERING_TIME, sizeof(GN_HYDROBOARD2_MIN_WATERING_TIME)); return GN_LEAF_PARAM_VALIDATOR_PASSED_CHANGED; } else if (GN_HYDROBOARD2_MAX_WATERING_TIME < **(double**) param_value) { memcpy(param_value, &GN_HYDROBOARD2_MAX_WATERING_TIME, sizeof(GN_HYDROBOARD2_MAX_WATERING_TIME)); return GN_LEAF_PARAM_VALIDATOR_PASSED_CHANGED; } _p1 = **(double**) param_value; ESP_LOGD(TAG, \"_watering_time_validator - param: %d\", (int )_p1); return GN_LEAF_PARAM_VALIDATOR_PASSED; }","title":"Leaves"},{"location":"reference/leaves/#leaves","text":"Every sensor or actuator is represented by a Leaf. The Leaf is the connection of the underlying hardware, it is designed to be reusable multiple times in a Node and to be configured in a consistent way. A Leaf represents the bridge between the User and the hardware layer, therefore it is handled by the GrowNode engine as a separated RTOS task, and is accessed in an asyncronous way.","title":"Leaves"},{"location":"reference/leaves/#using-leaves","text":"Every leaf shall expose a gn_leaf_config_callback callback function that initializes its resources. In order to add a leaf to a node, the gn_leaf_create function is called first: gn_leaf_handle_t gn_leaf_create(gn_node_handle_t node, const char *name, gn_leaf_config_callback leaf_config, size_t task_size) This binds the Leaf to the parent Node, and tells the Node to use the gn_leaf_config_callback callback to initialize the resources at the appropriate moment. Typical job of a config callback function is to load and initialize its parameters and allocate memory for the side structures. Callback definition is: typedef gn_leaf_descriptor_handle_t (*gn_leaf_config_callback)( gn_leaf_handle_t leaf_config); The gn_leaf_descriptor_handle_t is a reference to the information configured. GrowNode engine will use later those info to start the leaf. Another callback must be implemented in the leaf: typedef void (*gn_leaf_task_callback)(gn_leaf_handle_t leaf_config); In this callback it is contained the business logic of the leaf, like: reading the Leaf parameter status listening for parameter updates from external sources (network or internal) updating the user UI working with underlying hardware resources updating its parameters","title":"Using Leaves"},{"location":"reference/leaves/#examples","text":"//creates the moisture sensor moisture_leaf = gn_leaf_create(node, \"moisture\", gn_capacitive_moisture_sensor_config, 4096);","title":"Examples"},{"location":"reference/leaves/#user-defined-leaves","text":"This section aims to give you necessary knowledge over the Leaves management framework. Is intended for users that want to use preconfigured leaves or to build new leaves. It's a rather simple task and many working examples are present in the leaves folder. A Leaf is tipycally used to bridge the hardware layer, supported by a collection of Parameters that represents the inputs and outputs of its operations. A Leaf can also be used to coordinate other leaves by sending messages and modifying their parameters. In order to approach to this topic, you must understand the parameter API features.","title":"User defined Leaves"},{"location":"reference/leaves/#parameter-declaration","text":"The declaration of a parameter inside a Leaf is done by calling gn_leaf_param_create() . Signature: gn_leaf_param_handle_t gn_leaf_param_create(gn_leaf_handle_t leaf_config, const char *name, const gn_val_type_t type, const gn_val_t val, gn_leaf_param_access_type_t access, gn_leaf_param_storage_t storage, gn_validator_callback_t validator); The return type of this function is a reference to the parameter, that will be stored into the leaf for future use.","title":"Parameter declaration"},{"location":"reference/leaves/#parameter-types","text":"Parameters are strong typed. That means that internally into Grownode engine they are represented using C types. Types are enumerated in gn_val_type_t . typedef enum { GN_VAL_TYPE_STRING, /*!< character array, user defined dimension */ GN_VAL_TYPE_BOOLEAN, /*!< true/false */ GN_VAL_TYPE_DOUBLE, /*!< floating point with sign */ } gn_val_type_t; Storage of the value is made by an union called gn_val_t : typedef union { char *s; bool b; double d; } gn_val_t; As you can see from this definition, it is user responsibility to allocate memory in case of a char array parameter. This has to be done inside the Leaf code.","title":"Parameter Types"},{"location":"reference/leaves/#access-type","text":"Parameters can have multiple uses, and therefore its access type can be different: typedef enum { GN_LEAF_PARAM_ACCESS_ALL = 0x01, /*!< param can be modified both by the node and network (eg. local configuration settings)*/ GN_LEAF_PARAM_ACCESS_NETWORK = 0x02, /*!< param can be modified only by network (eg. configuration settings from environment)*/ GN_LEAF_PARAM_ACCESS_NODE = 0x03, /*!< param can be modified only by the node (eg. sensor data)*/ GN_LEAF_PARAM_ACCESS_NODE_INTERNAL = 0x04 /*!< param can be modified only by the node (eg. sensor data) and it is not shown externally*/ } gn_leaf_param_access_type_t; The access type is evaluated upon parameter change. If the request is not compatible with the access type (eg. a network request against a GN_LEAF_PARAM_ACCESS_NODE access type) the request won't have any effect.","title":"Access Type"},{"location":"reference/leaves/#storage","text":"Some parameters holds the board hardware configuration, like the GPIO pin a sensor is attached to, or board status information that neeed to survive over board restarts or power failures (like the standard power a pump shall be activated). Those parameters can be stored on each update in the ESP32 Non Volatile Storage (NVS). The current implementation stores in key-value pairs, before hashing the key using leaf name and parameter name. typedef enum { GN_LEAF_PARAM_STORAGE_PERSISTED, /*!< param is stored in NVS flash every time it changes*/ GN_LEAF_PARAM_STORAGE_VOLATILE /*< param is never stored in NVS flash*/ } gn_leaf_param_storage_t; Pay attention to not persist parameters that have continuous updates, like temperature. It can cause a fast degradation of the board memory!","title":"Storage"},{"location":"reference/leaves/#validators","text":"Making sure the parameter update arriving from the network makes sense can be a boring task for a leaf developer. And risk of forgetting a check and allow unsafe values can break the code or even make the system dangerous (think of turning on a pump at exceeding speed or without a time limit). For this reason, the Grownode platform exposes a reusable mechanism to make the code safer: parameter validators. Validators are functions compliant to the gn_validator_callback_t callback: typedef gn_leaf_param_validator_result_t (*gn_validator_callback_t)( gn_leaf_param_handle_t param, void **value); The intended behavior is to check the value agains predetermined values, and return the result code on its gn_leaf_param_validator_result_t variable: typedef enum { GN_LEAF_PARAM_VALIDATOR_PASSED = 0x000, /*!< value is compliant */ GN_LEAF_PARAM_VALIDATOR_ERROR_ABOVE_MAX = 0x001, /*!< value is over the maximum limit */ GN_LEAF_PARAM_VALIDATOR_ERROR_BELOW_MIN = 0x002, /*!< value is below the minimum limit */ GN_LEAF_PARAM_VALIDATOR_ERROR_NOT_ALLOWED = 0x100, /*!< value is not allowed for other reasons */ GN_LEAF_PARAM_VALIDATOR_ERROR_GENERIC = 0x101, /*!< algorithm has returned an error */ GN_LEAF_PARAM_VALIDATOR_PASSED_CHANGED = 0x200 /*!< value was not allowed but has been modified by the validator to be compliant*/ } gn_leaf_param_validator_result_t; As you can see, there is a possibility that the validator changes the value of the parameter, like if the value to be checked is below zero then set the value to zero. Standard validators are present for standard value types: gn_leaf_param_validator_result_t gn_validator_double_positive( gn_leaf_param_handle_t param, void **param_value); gn_leaf_param_validator_result_t gn_validator_double( gn_leaf_param_handle_t param, void **param_value); gn_leaf_param_validator_result_t gn_validator_boolean( gn_leaf_param_handle_t param, void **param_value); But it's easy to add new ones. Examples can be found in gn_hydroboard2_watering_control.c code: gn_leaf_param_validator_result_t _gn_hb2_watering_time_validator( gn_leaf_param_handle_t param, void **param_value) { double val; if (gn_leaf_param_get_value(param, &val) != GN_RET_OK) return GN_LEAF_PARAM_VALIDATOR_ERROR; double _p1 = **(double**) param_value; ESP_LOGD(TAG, \"_watering_time_validator - param: %d\", (int )_p1); if (GN_HYDROBOARD2_MIN_WATERING_TIME > **(double**) param_value) { memcpy(param_value, &GN_HYDROBOARD2_MIN_WATERING_TIME, sizeof(GN_HYDROBOARD2_MIN_WATERING_TIME)); return GN_LEAF_PARAM_VALIDATOR_PASSED_CHANGED; } else if (GN_HYDROBOARD2_MAX_WATERING_TIME < **(double**) param_value) { memcpy(param_value, &GN_HYDROBOARD2_MAX_WATERING_TIME, sizeof(GN_HYDROBOARD2_MAX_WATERING_TIME)); return GN_LEAF_PARAM_VALIDATOR_PASSED_CHANGED; } _p1 = **(double**) param_value; ESP_LOGD(TAG, \"_watering_time_validator - param: %d\", (int )_p1); return GN_LEAF_PARAM_VALIDATOR_PASSED; }","title":"Validators"},{"location":"reference/logging/","text":"Logging GrowNode uses ESP-IDF logging library to log messages. Every functionality has his own logging TAG, that can be used to specify log level at build or at runtime. eg: //set default log level esp_log_level_set(\"*\", ESP_LOG_INFO); //set this file log level esp_log_level_set(\"gn_main\", ESP_LOG_INFO); //core esp_log_level_set(\"grownode\", ESP_LOG_INFO); esp_log_level_set(\"gn_commons\", ESP_LOG_INFO); esp_log_level_set(\"gn_nvs\", ESP_LOG_INFO); esp_log_level_set(\"gn_mqtt_protocol\", ESP_LOG_DEBUG); esp_log_level_set(\"gn_network\", ESP_LOG_INFO); esp_log_level_set(\"gn_display\", ESP_LOG_INFO); //boards esp_log_level_set(\"gn_blink\", ESP_LOG_INFO); It is recommended in production code to set log level at appropriate value in the sdkconfig file. Due to distributed nature of this framework, it is useful to send log messages across the network. This is done by calling the gn_log() function: gn_err_t gn_log(char *log_tag, gn_log_level_t level, const char *message, ...); This will mimic the ESP_LOG() macro, but will also send the message to the network if the log level is enabled for that TAG. the gn_log_level_t struct mimics the ESP log levels, so you can use in the same way: gn_log(TAG, GN_LOG_INFO, \"easypot1 - measuring moisture: %f\", moist_act); Structure of the message is described in MQTT section.","title":"Logging"},{"location":"reference/logging/#logging","text":"GrowNode uses ESP-IDF logging library to log messages. Every functionality has his own logging TAG, that can be used to specify log level at build or at runtime. eg: //set default log level esp_log_level_set(\"*\", ESP_LOG_INFO); //set this file log level esp_log_level_set(\"gn_main\", ESP_LOG_INFO); //core esp_log_level_set(\"grownode\", ESP_LOG_INFO); esp_log_level_set(\"gn_commons\", ESP_LOG_INFO); esp_log_level_set(\"gn_nvs\", ESP_LOG_INFO); esp_log_level_set(\"gn_mqtt_protocol\", ESP_LOG_DEBUG); esp_log_level_set(\"gn_network\", ESP_LOG_INFO); esp_log_level_set(\"gn_display\", ESP_LOG_INFO); //boards esp_log_level_set(\"gn_blink\", ESP_LOG_INFO); It is recommended in production code to set log level at appropriate value in the sdkconfig file. Due to distributed nature of this framework, it is useful to send log messages across the network. This is done by calling the gn_log() function: gn_err_t gn_log(char *log_tag, gn_log_level_t level, const char *message, ...); This will mimic the ESP_LOG() macro, but will also send the message to the network if the log level is enabled for that TAG. the gn_log_level_t struct mimics the ESP log levels, so you can use in the same way: gn_log(TAG, GN_LOG_INFO, \"easypot1 - measuring moisture: %f\", moist_act); Structure of the message is described in MQTT section.","title":"Logging"},{"location":"reference/mqtt/","text":"MQTT GrowNode uses MQTT as messaging protocol. It has been choosen due to wide use across IoT community, becoming a de facto standard for those applications. Users can deploy their own MQTT server or use a public server in the network. GrowNode will connect to the MQTT server just after receiving wifi credentials. Two possible MQTT implementations are selectable from menuconfig Homie: an open standard for IoT messaging. We currently implement 4.0.0 version. See [Specification] (https://homieiot.github.io/specification/) Legacy: a custom protocol HOMIE [September 2022] from release 0.8.0, GrowNode supports HOMIE 4.0.0 as messaging standard! We think this is a great step in standardization, making the boards able to be discovered and talk with most popular IoT controllers (OpenHab, Home Assistant, Node-RED etc.) From 0.8.0 release, Homie terminology is converted in GrowNode as follows Homie Device -> GrowNode node Homie Node -> GrowNode leaf Homie Property -> Grownode parameter Configuration See Network Configuration for a basic startup. Parameters involved in the MQTT server configuration are described in gn_config_init_param_t struct to be passed to node creation: bool server_board_id_topic : whether grownode engine shall add the MAC address of the board in the topic prefix - default false; char server_base_topic[80] : the base topic where to publish messages, TO COMPLY WITH HOMIE STANDARD AND ENABLE AUTODISCOVERY MUST BE SET AS: homie/ ; char server_url[255] : URL of the server, specified with protocol and port - example: mqtt://192.168.1.170:1883 ; uint32_t server_keepalive_timer_sec : GrowNode engine will send a keepalive message to MQTT server. This indicates the seconds between two messages. if not found or 0, keepalive messages will not be triggered; Legacy Configuration See Network Configuration for a basic startup. Parameters involved in the MQTT server configuration are described in gn_config_init_param_t struct to be passed to node creation: bool server_board_id_topic : whether grownode engine shall add the MAC address of the board in the topic prefix - default false; char server_base_topic[80] : the base topic where to publish messages, format shall include all slashes - example: /grownode/test ; char server_url[255] : URL of the server, specified with protocol and port - example: mqtt://192.168.1.170:1883 ; uint32_t server_keepalive_timer_sec : GrowNode engine will send a keepalive message to MQTT server. This indicates the seconds between two messages. if not found or 0, keepalive messages will not be triggered; MQTT Protocol All messages are sent using QoS 0, retain = false. This to improve efficiency and performances on the node side. But this also means that if no listeners are subscribed when the message is lost. GrowNode uses JSON formatting to produce complex payloads. Parts in italic have to be replaced with your configuration. Startup messages Upon Server connection, the Node will send a startup message. From To Board Server Parameter Description Topic base /STS QoS 0 Payload { \"msgtype\": \"online\" } LWT messages LWT message (last will testament) is a particular message the MQTT server will publish if no messages are received from a certain time. From To Board Server Parameter Description Topic base /STS QoS 1 retain 1 Payload { \"msgtype\": \"offline\" } Node Config message This is a message showing the node configuration to the network. Currently, it is sent as keepalive. From To Board Server Parameter Description Topic base /STS QoS 0 Payload { \"msgtype\": \"config\"... (see example) } Example message: { \"msgtype\": \"config\", \"name\": \"node\", \"leaves\": [ { \"name\": \"blink\", \"leaf_type\": \"gpio\", \"params\": [ { \"name\": \"status\", \"type\": \"bool\", \"val\": true }, { \"name\": \"inverted\", \"type\": \"bool\", \"val\": false }, { \"name\": \"gpio\", \"type\": \"number\", \"val\": 2 } ] } ] } Leaf parameter change request To request a parameter to change, user shall send a mqtt message indicating the leaf and the parameter to change. This will be evaluated against the permissions for this parameter: From To Server Board Parameter Description Topic base / leaf / parameter /CMD QoS 0 Payload parameter-dependent Leaf parameter change notify When a parameter changes its status, if configured the board will send a parameter status change: From To Board Server Parameter Description Topic base / leaf / parameter /STS QoS 0 Payload parameter-dependent Discovery messages This feature is not yet completed. Please consider it experimental. Discovery messages are particular messages that allows servers like openHAB or HomeAssistant to automatically detect the node capabilities and expose them in their system. With this functionality users does not have to manually add sensors to their home automation servers. Parameters involved in the configuration are described in gn_config_init_param_t struct to be passed to node creation: bool server_discovery : whether the functionality shall be enabled - default false char server_discovery_prefix[80] : topic prefix From To Board Server Parameter Description Topic server_discovery_prefix QoS 0 Payload todo OTA message This message informs the node to upload the firmware from the config specified URL. This message can be sent also with retained flag = true, and will be resetted by the board upon processing. This in order to call the functionality even if waking up from deep sleep From To Server Board Parameter Description Topic base /CMD QoS 0 Payload OTA This gives the confirmation the OTA message has been processed and the OTA is in progress From To Board Server Parameter Description Topic base /STS QoS 0 Payload OTA Reboot message This message tells the node to reboot. This message can be sent also with retained flag = true, and will be resetted by the board upon processing. This in order to call the functionality even if waking up from deep sleep From To Server Board Parameter Description Topic base /CMD QoS 0 Payload RBT This gives the confirmation the reboot message has been processed and the board is rebooting From To Board Server Parameter Description Topic base /STS QoS 0 Payload RBT Reset message This message tells the node to reset the NVS. This will bring to the initial configuration, including provisioning. This message can be sent also with retained flag = true, and will be resetted by the board upon processing. This in order to call the functionality even if waking up from deep sleep From To Server Board Parameter Description Topic base /CMD QoS 0 Payload RST This gives the confirmation the reset message has been processed and the reset is in progress From To Board Server Parameter Description Topic base /STS QoS 0 Payload RST Log messages This is sent by the logging API From To Board Server Parameter Description Topic base /STS QoS 0 Payload { \"msgtype\": \"log\"; \"tag\": \" tag \"; \"lev\": \" lev \"; \"msg\": \" payload \" }","title":"MQTT"},{"location":"reference/mqtt/#mqtt","text":"GrowNode uses MQTT as messaging protocol. It has been choosen due to wide use across IoT community, becoming a de facto standard for those applications. Users can deploy their own MQTT server or use a public server in the network. GrowNode will connect to the MQTT server just after receiving wifi credentials. Two possible MQTT implementations are selectable from menuconfig Homie: an open standard for IoT messaging. We currently implement 4.0.0 version. See [Specification] (https://homieiot.github.io/specification/) Legacy: a custom protocol","title":"MQTT"},{"location":"reference/mqtt/#homie","text":"[September 2022] from release 0.8.0, GrowNode supports HOMIE 4.0.0 as messaging standard! We think this is a great step in standardization, making the boards able to be discovered and talk with most popular IoT controllers (OpenHab, Home Assistant, Node-RED etc.) From 0.8.0 release, Homie terminology is converted in GrowNode as follows Homie Device -> GrowNode node Homie Node -> GrowNode leaf Homie Property -> Grownode parameter","title":"HOMIE"},{"location":"reference/mqtt/#configuration","text":"See Network Configuration for a basic startup. Parameters involved in the MQTT server configuration are described in gn_config_init_param_t struct to be passed to node creation: bool server_board_id_topic : whether grownode engine shall add the MAC address of the board in the topic prefix - default false; char server_base_topic[80] : the base topic where to publish messages, TO COMPLY WITH HOMIE STANDARD AND ENABLE AUTODISCOVERY MUST BE SET AS: homie/ ; char server_url[255] : URL of the server, specified with protocol and port - example: mqtt://192.168.1.170:1883 ; uint32_t server_keepalive_timer_sec : GrowNode engine will send a keepalive message to MQTT server. This indicates the seconds between two messages. if not found or 0, keepalive messages will not be triggered;","title":"Configuration"},{"location":"reference/mqtt/#legacy","text":"","title":"Legacy"},{"location":"reference/mqtt/#configuration_1","text":"See Network Configuration for a basic startup. Parameters involved in the MQTT server configuration are described in gn_config_init_param_t struct to be passed to node creation: bool server_board_id_topic : whether grownode engine shall add the MAC address of the board in the topic prefix - default false; char server_base_topic[80] : the base topic where to publish messages, format shall include all slashes - example: /grownode/test ; char server_url[255] : URL of the server, specified with protocol and port - example: mqtt://192.168.1.170:1883 ; uint32_t server_keepalive_timer_sec : GrowNode engine will send a keepalive message to MQTT server. This indicates the seconds between two messages. if not found or 0, keepalive messages will not be triggered;","title":"Configuration"},{"location":"reference/mqtt/#mqtt-protocol","text":"All messages are sent using QoS 0, retain = false. This to improve efficiency and performances on the node side. But this also means that if no listeners are subscribed when the message is lost. GrowNode uses JSON formatting to produce complex payloads. Parts in italic have to be replaced with your configuration.","title":"MQTT Protocol"},{"location":"reference/mqtt/#startup-messages","text":"Upon Server connection, the Node will send a startup message. From To Board Server Parameter Description Topic base /STS QoS 0 Payload { \"msgtype\": \"online\" }","title":"Startup messages"},{"location":"reference/mqtt/#lwt-messages","text":"LWT message (last will testament) is a particular message the MQTT server will publish if no messages are received from a certain time. From To Board Server Parameter Description Topic base /STS QoS 1 retain 1 Payload { \"msgtype\": \"offline\" }","title":"LWT messages"},{"location":"reference/mqtt/#node-config-message","text":"This is a message showing the node configuration to the network. Currently, it is sent as keepalive. From To Board Server Parameter Description Topic base /STS QoS 0 Payload { \"msgtype\": \"config\"... (see example) } Example message: { \"msgtype\": \"config\", \"name\": \"node\", \"leaves\": [ { \"name\": \"blink\", \"leaf_type\": \"gpio\", \"params\": [ { \"name\": \"status\", \"type\": \"bool\", \"val\": true }, { \"name\": \"inverted\", \"type\": \"bool\", \"val\": false }, { \"name\": \"gpio\", \"type\": \"number\", \"val\": 2 } ] } ] }","title":"Node Config message"},{"location":"reference/mqtt/#leaf-parameter-change-request","text":"To request a parameter to change, user shall send a mqtt message indicating the leaf and the parameter to change. This will be evaluated against the permissions for this parameter: From To Server Board Parameter Description Topic base / leaf / parameter /CMD QoS 0 Payload parameter-dependent","title":"Leaf parameter change request"},{"location":"reference/mqtt/#leaf-parameter-change-notify","text":"When a parameter changes its status, if configured the board will send a parameter status change: From To Board Server Parameter Description Topic base / leaf / parameter /STS QoS 0 Payload parameter-dependent","title":"Leaf parameter change notify"},{"location":"reference/mqtt/#discovery-messages","text":"This feature is not yet completed. Please consider it experimental. Discovery messages are particular messages that allows servers like openHAB or HomeAssistant to automatically detect the node capabilities and expose them in their system. With this functionality users does not have to manually add sensors to their home automation servers. Parameters involved in the configuration are described in gn_config_init_param_t struct to be passed to node creation: bool server_discovery : whether the functionality shall be enabled - default false char server_discovery_prefix[80] : topic prefix From To Board Server Parameter Description Topic server_discovery_prefix QoS 0 Payload todo","title":"Discovery messages"},{"location":"reference/mqtt/#ota-message","text":"This message informs the node to upload the firmware from the config specified URL. This message can be sent also with retained flag = true, and will be resetted by the board upon processing. This in order to call the functionality even if waking up from deep sleep From To Server Board Parameter Description Topic base /CMD QoS 0 Payload OTA This gives the confirmation the OTA message has been processed and the OTA is in progress From To Board Server Parameter Description Topic base /STS QoS 0 Payload OTA","title":"OTA message"},{"location":"reference/mqtt/#reboot-message","text":"This message tells the node to reboot. This message can be sent also with retained flag = true, and will be resetted by the board upon processing. This in order to call the functionality even if waking up from deep sleep From To Server Board Parameter Description Topic base /CMD QoS 0 Payload RBT This gives the confirmation the reboot message has been processed and the board is rebooting From To Board Server Parameter Description Topic base /STS QoS 0 Payload RBT","title":"Reboot message"},{"location":"reference/mqtt/#reset-message","text":"This message tells the node to reset the NVS. This will bring to the initial configuration, including provisioning. This message can be sent also with retained flag = true, and will be resetted by the board upon processing. This in order to call the functionality even if waking up from deep sleep From To Server Board Parameter Description Topic base /CMD QoS 0 Payload RST This gives the confirmation the reset message has been processed and the reset is in progress From To Board Server Parameter Description Topic base /STS QoS 0 Payload RST","title":"Reset  message"},{"location":"reference/mqtt/#log-messages","text":"This is sent by the logging API From To Board Server Parameter Description Topic base /STS QoS 0 Payload { \"msgtype\": \"log\"; \"tag\": \" tag \"; \"lev\": \" lev \"; \"msg\": \" payload \" }","title":"Log messages"},{"location":"reference/networking/","text":"Networking GrowNode uses standard ESP32 provisioning framework to connect your wifi network. It can use SoftAP or BLE provisioning, to be specified from the build system . Once provisioned, GrowNode engine will try to estabilish a connection to the specified WiFi network during the gn_init() initialization process. If the network connection cannot be estabilished, the board can be configured to wait forever or to reset its provisioning status (cancelling the wifi credentials and restarting) in order to be ready to join another network. Configuration See Network Configuration for a basic startup. Parameters involved in the WiFi configuration are described in gn_config_init_param_t struct to be passed to node creation: bool provisioning_security : defines if the provisioning protocol should use encrypted communication and proof of possession - default true; char provisioning_password[9] : define the password an user shall enter to prove being a grownode administrator; int16_t wifi_retries_before_reset_provisioning : how many times the wifi driver tries to connect to the network before resetting provisioning info - -1 to never lose provisioning (warning: in case of SSID change, no way to reset!). Upon connection, a GN_NET_CONNECTED_EVENT is triggered, and a GN_NET_DISCONNECTED_EVENT is triggered upon disconnection.","title":"Networking"},{"location":"reference/networking/#networking","text":"GrowNode uses standard ESP32 provisioning framework to connect your wifi network. It can use SoftAP or BLE provisioning, to be specified from the build system . Once provisioned, GrowNode engine will try to estabilish a connection to the specified WiFi network during the gn_init() initialization process. If the network connection cannot be estabilished, the board can be configured to wait forever or to reset its provisioning status (cancelling the wifi credentials and restarting) in order to be ready to join another network.","title":"Networking"},{"location":"reference/networking/#configuration","text":"See Network Configuration for a basic startup. Parameters involved in the WiFi configuration are described in gn_config_init_param_t struct to be passed to node creation: bool provisioning_security : defines if the provisioning protocol should use encrypted communication and proof of possession - default true; char provisioning_password[9] : define the password an user shall enter to prove being a grownode administrator; int16_t wifi_retries_before_reset_provisioning : how many times the wifi driver tries to connect to the network before resetting provisioning info - -1 to never lose provisioning (warning: in case of SSID change, no way to reset!). Upon connection, a GN_NET_CONNECTED_EVENT is triggered, and a GN_NET_DISCONNECTED_EVENT is triggered upon disconnection.","title":"Configuration"},{"location":"reference/node/","text":"Node The core element of a GrowNode implementation is the Node. It represents the container and the entry point for the board capabilities. In order to properly create a Node, a configuration shall be supplied. This is done by creating a gn_config_handle_t data structure and then injecting it using the gn_node_create() function. A gn_node_handle_t pointer will be returned, that is the reference to be passed in the next board configuration steps to create the necessary Leaves. To start the Node execution loop, the gn_node_start() function has to be called. This will trigger the xTaskCreate() RTOS function per each configured leaf. Although a Node is intended to survive for the entire duration of the application, a gn_node_destroy() function is provided, to release Node resources. Node statuses The Node initialization process implies, depending on the configuration, the start of several services like WiFi provisioning, MQTT server connection, that requires time. In order to give the user the possibility to perform operations while the init process continues (like showing a message on the display or handle issues) it is possible to use a loop to retrieve the Node status and wait until init ends, and then proceed. A node has a status represented by the gn_node_status_t enum. The default initial status is GN_NODE_STATUS_NOT_INITIALIZED . During initialization process, it goes into GN_NODE_STATUS_INITIALIZING . If some errors occur, a specific status is associated (see API ). If everything goes well, the status is moved to GN_NODE_STATUS_READY_TO_START . This gives the user the OK to exit from the wait loop and proceed with starting the node operations. After a successful call of gn_node_start() the node goes into GN_NODE_STATUS_STARTED . A good main() infinite loop could check if the status of the node changes and react accordingly. Note: you won't find it in the code as per today :) Code Sample: Node creation and startup gn_config_init_param_t config_init = { .provisioning_password = \"grownode\", .server_base_topic = \"/grownode/mqttroottopic\", ... }; //creates the config handle gn_config_handle_t config = gn_init(&config_init); ... //creates a new node gn_node_config_handle_t node = gn_node_create(config, \"my root node\"); ... //waits until the config process ends while (gn_get_status(config) != GN_NODE_STATUS_READY_TO_START) { vTaskDelay(1000 / portTICK_PERIOD_MS); ESP_LOGI(TAG, \"grownode startup status: %s\", gn_get_status_description(config)); } ... //finally, start node gn_node_start(node);","title":"Node"},{"location":"reference/node/#node","text":"The core element of a GrowNode implementation is the Node. It represents the container and the entry point for the board capabilities. In order to properly create a Node, a configuration shall be supplied. This is done by creating a gn_config_handle_t data structure and then injecting it using the gn_node_create() function. A gn_node_handle_t pointer will be returned, that is the reference to be passed in the next board configuration steps to create the necessary Leaves. To start the Node execution loop, the gn_node_start() function has to be called. This will trigger the xTaskCreate() RTOS function per each configured leaf. Although a Node is intended to survive for the entire duration of the application, a gn_node_destroy() function is provided, to release Node resources.","title":"Node"},{"location":"reference/node/#node-statuses","text":"The Node initialization process implies, depending on the configuration, the start of several services like WiFi provisioning, MQTT server connection, that requires time. In order to give the user the possibility to perform operations while the init process continues (like showing a message on the display or handle issues) it is possible to use a loop to retrieve the Node status and wait until init ends, and then proceed. A node has a status represented by the gn_node_status_t enum. The default initial status is GN_NODE_STATUS_NOT_INITIALIZED . During initialization process, it goes into GN_NODE_STATUS_INITIALIZING . If some errors occur, a specific status is associated (see API ). If everything goes well, the status is moved to GN_NODE_STATUS_READY_TO_START . This gives the user the OK to exit from the wait loop and proceed with starting the node operations. After a successful call of gn_node_start() the node goes into GN_NODE_STATUS_STARTED . A good main() infinite loop could check if the status of the node changes and react accordingly. Note: you won't find it in the code as per today :)","title":"Node statuses"},{"location":"reference/node/#code-sample-node-creation-and-startup","text":"gn_config_init_param_t config_init = { .provisioning_password = \"grownode\", .server_base_topic = \"/grownode/mqttroottopic\", ... }; //creates the config handle gn_config_handle_t config = gn_init(&config_init); ... //creates a new node gn_node_config_handle_t node = gn_node_create(config, \"my root node\"); ... //waits until the config process ends while (gn_get_status(config) != GN_NODE_STATUS_READY_TO_START) { vTaskDelay(1000 / portTICK_PERIOD_MS); ESP_LOGI(TAG, \"grownode startup status: %s\", gn_get_status_description(config)); } ... //finally, start node gn_node_start(node);","title":"Code Sample: Node creation and startup"},{"location":"reference/parameters/","text":"Parameters GrowNode allows users to access Leaves input and outputs through Parameters. A parameter defines its behavior and holds its value. Depending on their configuration, parameters can be exposed and accessed from inside the code (eg. from an onboard temperature controller) or from the network (eg. to monitor the water level). They can be also updated in both ways. Parameters can be stored in the NVS flash (the ESP32 'hard drive') in order to be persisted over board restart, in a transparent way (no code needed). Initialization Each Leaf has a predetermined set of parameters. Those are initialized in the configuration phase described in the Leaves section. However, the initial values can be overridden by the user. For instance, a parameter defining a GPIO pin should be customized depending on the board circuit. To do this, the gn_leaf_param_init_XXX() functions are defined. Example: gn_leaf_handle_t lights = gn_leaf_create(node, \"light switch\", gn_gpio_config, 4096); gn_leaf_param_init_double(lights, GN_GPIO_PARAM_GPIO, 25); Here, a lights leaf is created using the gn_gpio_config callback. This leaf (see gn_gpio leaf code) has a parameter called GN_GPIO_PARAM_GPIO that represents the GPIO to control. This code assigns the value 25 to that parameter at startup. Overwrite stored parameters A leaf parameter can be stored in the board flash depending on its configuration. Standard behavior is that on next startup the init function will be ignored. This could be overridden by using the gn_leaf_param_force_XXX() instead. this will set the parameter at the desired value ignoring the previously set value. Fast creation Some leaves has convenient functions created to perform creation and initialization in a compact form. Those functions have the suffix _fastcreate (see for instance gn_gpio_fastcreate() on gn_gpio.c leaf) Update A leaf parameter can be updated: from the network: see MQTT Protocol from the code When updating from user code, the gn_leaf_param_set_XXX() functions are used. They inform the leaf that the parameter shall be changed to a new value. This is done via event passing as the leaf resides to another task, so it's an asynchronous call. Code Sample: Leaf declaration and parameters initialization This is the complete code to create and configure a BME280 Leaf sensor, a temperature + humidity + pressure sensor (for complete description of this sensor, see leaves gn_leaf_handle_t env_thp = gn_leaf_create(node, \"bme280\", gn_bme280_config, 8192); gn_leaf_param_init_double(env_thp, GN_BME280_PARAM_SDA, 21); gn_leaf_param_init_double(env_thp, GN_BME280_PARAM_SCL, 22); gn_leaf_param_init_bool(env_thp, GN_BME280_PARAM_ACTIVE, true); gn_leaf_param_init_double(env_thp, GN_BME280_PARAM_UPDATE_TIME_SEC, 10);","title":"Parameters"},{"location":"reference/parameters/#parameters","text":"GrowNode allows users to access Leaves input and outputs through Parameters. A parameter defines its behavior and holds its value. Depending on their configuration, parameters can be exposed and accessed from inside the code (eg. from an onboard temperature controller) or from the network (eg. to monitor the water level). They can be also updated in both ways. Parameters can be stored in the NVS flash (the ESP32 'hard drive') in order to be persisted over board restart, in a transparent way (no code needed).","title":"Parameters"},{"location":"reference/parameters/#initialization","text":"Each Leaf has a predetermined set of parameters. Those are initialized in the configuration phase described in the Leaves section. However, the initial values can be overridden by the user. For instance, a parameter defining a GPIO pin should be customized depending on the board circuit. To do this, the gn_leaf_param_init_XXX() functions are defined. Example: gn_leaf_handle_t lights = gn_leaf_create(node, \"light switch\", gn_gpio_config, 4096); gn_leaf_param_init_double(lights, GN_GPIO_PARAM_GPIO, 25); Here, a lights leaf is created using the gn_gpio_config callback. This leaf (see gn_gpio leaf code) has a parameter called GN_GPIO_PARAM_GPIO that represents the GPIO to control. This code assigns the value 25 to that parameter at startup.","title":"Initialization"},{"location":"reference/parameters/#overwrite-stored-parameters","text":"A leaf parameter can be stored in the board flash depending on its configuration. Standard behavior is that on next startup the init function will be ignored. This could be overridden by using the gn_leaf_param_force_XXX() instead. this will set the parameter at the desired value ignoring the previously set value.","title":"Overwrite stored parameters"},{"location":"reference/parameters/#fast-creation","text":"Some leaves has convenient functions created to perform creation and initialization in a compact form. Those functions have the suffix _fastcreate (see for instance gn_gpio_fastcreate() on gn_gpio.c leaf)","title":"Fast creation"},{"location":"reference/parameters/#update","text":"A leaf parameter can be updated: from the network: see MQTT Protocol from the code When updating from user code, the gn_leaf_param_set_XXX() functions are used. They inform the leaf that the parameter shall be changed to a new value. This is done via event passing as the leaf resides to another task, so it's an asynchronous call.","title":"Update"},{"location":"reference/parameters/#code-sample-leaf-declaration-and-parameters-initialization","text":"This is the complete code to create and configure a BME280 Leaf sensor, a temperature + humidity + pressure sensor (for complete description of this sensor, see leaves gn_leaf_handle_t env_thp = gn_leaf_create(node, \"bme280\", gn_bme280_config, 8192); gn_leaf_param_init_double(env_thp, GN_BME280_PARAM_SDA, 21); gn_leaf_param_init_double(env_thp, GN_BME280_PARAM_SCL, 22); gn_leaf_param_init_bool(env_thp, GN_BME280_PARAM_ACTIVE, true); gn_leaf_param_init_double(env_thp, GN_BME280_PARAM_UPDATE_TIME_SEC, 10);","title":"Code Sample: Leaf declaration and parameters initialization"},{"location":"reference/power_management/","text":"Sleep Modes GrowNode implements Deep and Light sleep functionalities. These are useful to save energy when no active actions are needed and let the board be battery powered. In order to understand basic sleep mode functionalities, please refer to ESP32 reference guide Configuration Sleep management is configured in init parameters: gn_config_init_param_t config_init = { ... .wakeup_time_millisec = 5000LL, .sleep_delay_millisec = 50LL, .sleep_time_millisec = 120000LL, .sleep_mode = GN_SLEEP_MODE_DEEP }; Main parameters are: - gn_sleep_mode_t sleep_mode - define if and how the board must sleep. possible values are GN_SLEEP_MODE_NONE (never sleeps), GN_SLEEP_MODE_LIGHT (light sleep), GN_SLEEP_MODE_DEEP (deep sleep) - uint64_t wakeup_time_millisec - if sleep mode is GN_SLEEP_MODE_LIGHT or GN_SLEEP_MODE_DEEP, sets for how long the board must stay on (counted from boot) - uint64_t sleep_time_millisec - if sleep mode is GN_SLEEP_MODE_LIGHT or GN_SLEEP_MODE_DEEP, sets for how long the board must sleep - uint64_t sleep_delay_millisec - if sleep mode is GN_SLEEP_MODE_LIGHT or GN_SLEEP_MODE_DEEP, sets for how long the board must stay on waiting for leaves to complete its job before sleeping Sleep start cycle (automatic) In light and deep sleep mode, a timer sets until when the board must stay on. Upon timeout, the board sends to its leaves a GN_NODE_LIGHT_SLEEP_START_EVENT o GN_NODE_DEEP_SLEEP_START_EVENT. This allows the leaves to perform housekeeping work in preparation to sleep. Then, waits for sleep_delay_millisec . After this time, its starts checking whether leaves are still working. Once all leaves are in blocking status if releases the MQTT and WIFI connection and start the sleep cycle for sleep_time_millisec . Manual sleep cycle management If you want to sleep the board directly from your code, you can use the gn_err_t gn_node_sleep(gn_node_handle_t node, gn_sleep_mode_t sleep_mode, uint64_t delay_msec, uint64_t millisec) function. It starts the same cycle called in automatic mode.","title":"Sleep Modes"},{"location":"reference/power_management/#sleep-modes","text":"GrowNode implements Deep and Light sleep functionalities. These are useful to save energy when no active actions are needed and let the board be battery powered. In order to understand basic sleep mode functionalities, please refer to ESP32 reference guide","title":"Sleep Modes"},{"location":"reference/power_management/#configuration","text":"Sleep management is configured in init parameters: gn_config_init_param_t config_init = { ... .wakeup_time_millisec = 5000LL, .sleep_delay_millisec = 50LL, .sleep_time_millisec = 120000LL, .sleep_mode = GN_SLEEP_MODE_DEEP }; Main parameters are: - gn_sleep_mode_t sleep_mode - define if and how the board must sleep. possible values are GN_SLEEP_MODE_NONE (never sleeps), GN_SLEEP_MODE_LIGHT (light sleep), GN_SLEEP_MODE_DEEP (deep sleep) - uint64_t wakeup_time_millisec - if sleep mode is GN_SLEEP_MODE_LIGHT or GN_SLEEP_MODE_DEEP, sets for how long the board must stay on (counted from boot) - uint64_t sleep_time_millisec - if sleep mode is GN_SLEEP_MODE_LIGHT or GN_SLEEP_MODE_DEEP, sets for how long the board must sleep - uint64_t sleep_delay_millisec - if sleep mode is GN_SLEEP_MODE_LIGHT or GN_SLEEP_MODE_DEEP, sets for how long the board must stay on waiting for leaves to complete its job before sleeping","title":"Configuration"},{"location":"reference/power_management/#sleep-start-cycle-automatic","text":"In light and deep sleep mode, a timer sets until when the board must stay on. Upon timeout, the board sends to its leaves a GN_NODE_LIGHT_SLEEP_START_EVENT o GN_NODE_DEEP_SLEEP_START_EVENT. This allows the leaves to perform housekeeping work in preparation to sleep. Then, waits for sleep_delay_millisec . After this time, its starts checking whether leaves are still working. Once all leaves are in blocking status if releases the MQTT and WIFI connection and start the sleep cycle for sleep_time_millisec .","title":"Sleep start cycle (automatic)"},{"location":"reference/power_management/#manual-sleep-cycle-management","text":"If you want to sleep the board directly from your code, you can use the gn_err_t gn_node_sleep(gn_node_handle_t node, gn_sleep_mode_t sleep_mode, uint64_t delay_msec, uint64_t millisec) function. It starts the same cycle called in automatic mode.","title":"Manual sleep cycle management"},{"location":"reference/synapses/","text":"Synapses Leaves are thought as connection to hardware, but sometimes it is not enough to connect a sensor and publish its controls and values. A classic example is the need to water a pot at fixed rates or depending on other sensor values (eg. temperature and humidity). This is where Synapses helps. Synapses are representing the logic of a board. Scope of those components is to let the user command not only the sensor and actuators, but also the logic of how they behave together. Synapses and leaves Synapses are currently coded as leaves. They differentiates only on the location, as they resides on grownode\\synapses folder. All functionalities are completely identical to leaves.","title":"Synapses"},{"location":"reference/synapses/#synapses","text":"Leaves are thought as connection to hardware, but sometimes it is not enough to connect a sensor and publish its controls and values. A classic example is the need to water a pot at fixed rates or depending on other sensor values (eg. temperature and humidity). This is where Synapses helps. Synapses are representing the logic of a board. Scope of those components is to let the user command not only the sensor and actuators, but also the logic of how they behave together.","title":"Synapses"},{"location":"reference/synapses/#synapses-and-leaves","text":"Synapses are currently coded as leaves. They differentiates only on the location, as they resides on grownode\\synapses folder. All functionalities are completely identical to leaves.","title":"Synapses and leaves"},{"location":"reference/leaves_list/","text":"Standard Leaves Here you can find a list of standard leaves proided with GrowNode system.","title":"Standard Leaves"},{"location":"reference/leaves_list/#standard-leaves","text":"Here you can find a list of standard leaves proided with GrowNode system.","title":"Standard Leaves"},{"location":"reference/leaves_list/bme280/","text":"BME280 This leaf controls a BME280 temperature/humidity/pressure sensor. It connects to the sensor through I2C protocol and scans its parameters at predefined rate. Parameters See API Docs Example gn_leaf_handle_t env_thp = gn_leaf_create(node, BME280, gn_bme280_config, 8192); gn_leaf_param_init_double(env_thp, GN_BME280_PARAM_SDA, 21); gn_leaf_param_init_double(env_thp, GN_BME280_PARAM_SCL, 22); gn_leaf_param_init_bool(env_thp, GN_BME280_PARAM_ACTIVE, true); gn_leaf_param_init_double(env_thp, GN_BME280_PARAM_UPDATE_TIME_SEC, 10);","title":"BME280"},{"location":"reference/leaves_list/bme280/#bme280","text":"This leaf controls a BME280 temperature/humidity/pressure sensor. It connects to the sensor through I2C protocol and scans its parameters at predefined rate.","title":"BME280"},{"location":"reference/leaves_list/bme280/#parameters","text":"See API Docs","title":"Parameters"},{"location":"reference/leaves_list/bme280/#example","text":"gn_leaf_handle_t env_thp = gn_leaf_create(node, BME280, gn_bme280_config, 8192); gn_leaf_param_init_double(env_thp, GN_BME280_PARAM_SDA, 21); gn_leaf_param_init_double(env_thp, GN_BME280_PARAM_SCL, 22); gn_leaf_param_init_bool(env_thp, GN_BME280_PARAM_ACTIVE, true); gn_leaf_param_init_double(env_thp, GN_BME280_PARAM_UPDATE_TIME_SEC, 10);","title":"Example"},{"location":"reference/leaves_list/ina219/","text":"INA219 This leaf controls a INA219 current/voltage sensor through I2C protocol. It is useful when you need control over an electrical load or when running with batteries and you need to measure the battery status. It can also be used to build an oscilloscope. Functionalities It collects measurements from sensor for samp_cycles cycles waiting each cycle a samp_interval . After this collection time, it computes the average measure and updates the final value. This leaf can be used in two ways through the working_mode parameter: sending measurement to a telegraf server, in influxdb protocol through UDP. This is useful if you want to analyze metrics through influxdb or eg. directly connected to a grafana server using internal parameters to store measured values Parameters name description type default access storage valid values active whether INA219 shall be enabled boolean true GN_LEAF_PARAM_ACCESS_ALL GN_LEAF_PARAM_STORAGE_PERSISTED true/false ip ip address of the server string null GN_LEAF_PARAM_ACCESS_ALL GN_LEAF_PARAM_STORAGE_PERSISTED 16 char array port port of the server double 8094 GN_LEAF_PARAM_ACCESS_ALL GN_LEAF_PARAM_STORAGE_PERSISTED true/false samp_cycles sampling cycles double 1 GN_LEAF_PARAM_ACCESS_ALL GN_LEAF_PARAM_STORAGE_PERSISTED positive double samp_interval sampling interval, (approx) in msec double 1000 GN_LEAF_PARAM_ACCESS_ALL GN_LEAF_PARAM_STORAGE_PERSISTED positive double sda SDA PIN double 26 GN_LEAF_PARAM_ACCESS_NODE_INTERNAL GN_LEAF_PARAM_STORAGE_PERSISTED positive double scl SCL PIN double 26 GN_LEAF_PARAM_ACCESS_NODE_INTERNAL GN_LEAF_PARAM_STORAGE_PERSISTED positive double working_mode 0 = through UDP via influxdb protocol, 1 = parameters, 2 both double 1 GN_LEAF_PARAM_ACCESS_ALL GN_LEAF_PARAM_STORAGE_PERSISTED double positive power last power measured, in mW double 0 GN_LEAF_PARAM_ACCESS_NETWORK GN_LEAF_PARAM_STORAGE_VOLATILE any voltage last voltage measured, in mV double 0 GN_LEAF_PARAM_ACCESS_NETWORK GN_LEAF_PARAM_STORAGE_VOLATILE any shunt_voltage last shunt voltage measured, in mV double 0 GN_LEAF_PARAM_ACCESS_NETWORK GN_LEAF_PARAM_STORAGE_VOLATILE any bus_voltage last bus voltage measured, in mV double 0 GN_LEAF_PARAM_ACCESS_NETWORK GN_LEAF_PARAM_STORAGE_VOLATILE any current last current measured, in mA double 0 GN_LEAF_PARAM_ACCESS_NETWORK GN_LEAF_PARAM_STORAGE_VOLATILE any Example gn_leaf_handle_t ina219 = gn_leaf_create(node, \"ina219\", gn_leaf_ina219_config, 8192, GN_LEAF_TASK_PRIORITY); gn_leaf_param_init_bool(ina219, GN_LEAF_INA219_PARAM_ACTIVE, true); char* ip = calloc(16, sizeof(char)); strncpy(ip, \"192.168.1.20\", 16); gn_leaf_param_init_string(ina219, GN_LEAF_INA219_PARAM_IP, ip); gn_leaf_param_init_double(ina219, GN_LEAF_INA219_PARAM_PORT, 8094); gn_leaf_param_init_double(ina219, GN_LEAF_INA219_PARAM_SAMPLING_CYCLES, 5); gn_leaf_param_init_double(ina219, GN_LEAF_INA219_PARAM_SAMPLING_INTERVAL, 10); gn_leaf_param_init_double(ina219, GN_LEAF_INA219_PARAM_SDA, 26); gn_leaf_param_init_double(ina219, GN_LEAF_INA219_PARAM_SCL, 27); gn_leaf_param_init_double(ina219, GN_LEAF_INA219_PARAM_WORKING_MODE, 1);","title":"INA219"},{"location":"reference/leaves_list/ina219/#ina219","text":"This leaf controls a INA219 current/voltage sensor through I2C protocol. It is useful when you need control over an electrical load or when running with batteries and you need to measure the battery status. It can also be used to build an oscilloscope.","title":"INA219"},{"location":"reference/leaves_list/ina219/#functionalities","text":"It collects measurements from sensor for samp_cycles cycles waiting each cycle a samp_interval . After this collection time, it computes the average measure and updates the final value. This leaf can be used in two ways through the working_mode parameter: sending measurement to a telegraf server, in influxdb protocol through UDP. This is useful if you want to analyze metrics through influxdb or eg. directly connected to a grafana server using internal parameters to store measured values","title":"Functionalities"},{"location":"reference/leaves_list/ina219/#parameters","text":"name description type default access storage valid values active whether INA219 shall be enabled boolean true GN_LEAF_PARAM_ACCESS_ALL GN_LEAF_PARAM_STORAGE_PERSISTED true/false ip ip address of the server string null GN_LEAF_PARAM_ACCESS_ALL GN_LEAF_PARAM_STORAGE_PERSISTED 16 char array port port of the server double 8094 GN_LEAF_PARAM_ACCESS_ALL GN_LEAF_PARAM_STORAGE_PERSISTED true/false samp_cycles sampling cycles double 1 GN_LEAF_PARAM_ACCESS_ALL GN_LEAF_PARAM_STORAGE_PERSISTED positive double samp_interval sampling interval, (approx) in msec double 1000 GN_LEAF_PARAM_ACCESS_ALL GN_LEAF_PARAM_STORAGE_PERSISTED positive double sda SDA PIN double 26 GN_LEAF_PARAM_ACCESS_NODE_INTERNAL GN_LEAF_PARAM_STORAGE_PERSISTED positive double scl SCL PIN double 26 GN_LEAF_PARAM_ACCESS_NODE_INTERNAL GN_LEAF_PARAM_STORAGE_PERSISTED positive double working_mode 0 = through UDP via influxdb protocol, 1 = parameters, 2 both double 1 GN_LEAF_PARAM_ACCESS_ALL GN_LEAF_PARAM_STORAGE_PERSISTED double positive power last power measured, in mW double 0 GN_LEAF_PARAM_ACCESS_NETWORK GN_LEAF_PARAM_STORAGE_VOLATILE any voltage last voltage measured, in mV double 0 GN_LEAF_PARAM_ACCESS_NETWORK GN_LEAF_PARAM_STORAGE_VOLATILE any shunt_voltage last shunt voltage measured, in mV double 0 GN_LEAF_PARAM_ACCESS_NETWORK GN_LEAF_PARAM_STORAGE_VOLATILE any bus_voltage last bus voltage measured, in mV double 0 GN_LEAF_PARAM_ACCESS_NETWORK GN_LEAF_PARAM_STORAGE_VOLATILE any current last current measured, in mA double 0 GN_LEAF_PARAM_ACCESS_NETWORK GN_LEAF_PARAM_STORAGE_VOLATILE any","title":"Parameters"},{"location":"reference/leaves_list/ina219/#example","text":"gn_leaf_handle_t ina219 = gn_leaf_create(node, \"ina219\", gn_leaf_ina219_config, 8192, GN_LEAF_TASK_PRIORITY); gn_leaf_param_init_bool(ina219, GN_LEAF_INA219_PARAM_ACTIVE, true); char* ip = calloc(16, sizeof(char)); strncpy(ip, \"192.168.1.20\", 16); gn_leaf_param_init_string(ina219, GN_LEAF_INA219_PARAM_IP, ip); gn_leaf_param_init_double(ina219, GN_LEAF_INA219_PARAM_PORT, 8094); gn_leaf_param_init_double(ina219, GN_LEAF_INA219_PARAM_SAMPLING_CYCLES, 5); gn_leaf_param_init_double(ina219, GN_LEAF_INA219_PARAM_SAMPLING_INTERVAL, 10); gn_leaf_param_init_double(ina219, GN_LEAF_INA219_PARAM_SDA, 26); gn_leaf_param_init_double(ina219, GN_LEAF_INA219_PARAM_SCL, 27); gn_leaf_param_init_double(ina219, GN_LEAF_INA219_PARAM_WORKING_MODE, 1);","title":"Example"},{"location":"tutorials/","text":"GrowNode Tutorials In this section of GrowNode's documentation you will find some tutorials that will make your experience with GrowNode simpler, with step-by-step instructions about different topics. These are the tutorials now available. Getting started Here you can find step-by-step instructions explaining how to deploy the GrowNode development environment on your workstation, depending on your operating system. Windows Windows 10/11 - Easy In this tutorial you will install the Eclipse IDE and all the tools required for using GrowNode using the auto-installer provided by the ESP-IDF environment. Super easy! Linux Ubuntu 18.04 and 20.04 - Easy In this tutorial you will install the Eclipse IDE and all the tools required for using GrowNode mostly using a graphical interface. Note: this procedure is simpler but installs the very last ESP-IDF version instead of v4.4, which may introduce some incompatibilities with GrowNode in the future. No one has been detected by now. Ubuntu 18.04 and 20.04 - Advanced This tutorial explains how to install the basic libraries needed to build GrowNode projects without relying on a particular IDE. It also explains how to install the Eclipse IDE separately, and link it to an existing GrowNode building environment. Home automation server These tutorials show how to install a MQTT broker and the openHAB home automation platform, which can be then used to monitor and control GrowNode remotely (both manually and automatically). Linux Ubuntu 18.04 and 20.04 - Easy This tutorial explains ho to install Mosquitto and openHAB 3.2 on Ubuntu 18.04 and 20.04 using ready-made packages. Simple as few shell commands!","title":"GrowNode Tutorials"},{"location":"tutorials/#grownode-tutorials","text":"In this section of GrowNode's documentation you will find some tutorials that will make your experience with GrowNode simpler, with step-by-step instructions about different topics. These are the tutorials now available.","title":"GrowNode Tutorials"},{"location":"tutorials/#getting-started","text":"Here you can find step-by-step instructions explaining how to deploy the GrowNode development environment on your workstation, depending on your operating system.","title":"Getting started"},{"location":"tutorials/#windows","text":"Windows 10/11 - Easy In this tutorial you will install the Eclipse IDE and all the tools required for using GrowNode using the auto-installer provided by the ESP-IDF environment. Super easy!","title":"Windows"},{"location":"tutorials/#linux","text":"Ubuntu 18.04 and 20.04 - Easy In this tutorial you will install the Eclipse IDE and all the tools required for using GrowNode mostly using a graphical interface. Note: this procedure is simpler but installs the very last ESP-IDF version instead of v4.4, which may introduce some incompatibilities with GrowNode in the future. No one has been detected by now. Ubuntu 18.04 and 20.04 - Advanced This tutorial explains how to install the basic libraries needed to build GrowNode projects without relying on a particular IDE. It also explains how to install the Eclipse IDE separately, and link it to an existing GrowNode building environment.","title":"Linux"},{"location":"tutorials/#home-automation-server","text":"These tutorials show how to install a MQTT broker and the openHAB home automation platform, which can be then used to monitor and control GrowNode remotely (both manually and automatically).","title":"Home automation server"},{"location":"tutorials/#linux_1","text":"Ubuntu 18.04 and 20.04 - Easy This tutorial explains ho to install Mosquitto and openHAB 3.2 on Ubuntu 18.04 and 20.04 using ready-made packages. Simple as few shell commands!","title":"Linux"},{"location":"tutorials/openhab_ubuntu1804_2004_easy/","text":"How to install Mosquitto and openHAB on Ubuntu 18.04 and 20.04 - Easy version Updated on February 6, 2022 Introduction With this step-by-step tutorial you will be able to quickly deploy a message broker and the openHAB automation platform on your Ubuntu 18.04 or 20.04 workstation. How to link openHAB to GrowNode will be tackled in a dedicated tutorial. At the end of the tutorial you will have: installed the Mosquitto MQTT message broker installed a MQTT client tested the reception of messages from GrowNode (if you have a provisioned working board) installed openHAB 3.2 set up your openHAB access Notes: The same steps should also apply for Ubuntu 18.10 and 20.10, but we haven't tried yet. Let us know if you did! Older versions of Ubuntu do not satisfy the minimal requirements out-of-the-box, so they are not officially supported by GrowNode. This procedure could be also used to create an Ubuntu virtual machine to test the openHAB automation server without affecting your main system. Disclaimer Here we describe the basic steps to deploy a demonstrative system that can be used as a starting point. Fine tunings and ad-hoc implementations are out of scope for this document. A proper openHAB installation should be deployed on a machine with a fixed IP within your WiFi network. We assume that you know the IP address/nameserver of your workstation. How to get/fix your IP is out of scope here. Prerequisites at least 1.5 Gb free space on hard drive (only for software components, more will be needed to store data retrieved from your GrowNode) at least 4 Gb RAM Step 1: Check your JAVA installation openHAB 3.2 requires JAVA 11 to run. Newer versions are not supported. You may have already installed JAVA 11 on your system. Check it by running the command: java --version If the command runs and returns a JAVA version equal to 11, you are virtually ok and can move to the next step. However, if you have the standard OpenJDK JAVA on your system, note that openHAB documentation suggests to use the Azul Zulu OpenJDK JAVA 11 package instead. Indeed, OpenJDK is reported to work with some limitations with openHAB. If you have no JAVA 11, or you want to install the recommended Azul Zulu OpenJDK Java 11, refer to the next paragraph. Installing the Azul Zulu OpenJDK JAVA 11 package Open the Azul Zulu Download page and download the latest Linux JAVA 11 package for your architecture in .deb format . If you have a standard Linux workstation or virtual machine your architecture is most probably x86 64-bit Open the downloaded file (double click on it) and select \"Install\" in the window that appears... and that's all! :) Check the proper installation with java --version in a terminal. Step 2: Installing Mosquitto MQTT message broker Mosquitto is a message broker using the MQTT protocol. GrowNode natively supports MQTT and Mosquitto is a lightweight option to receive all the messages sent by GrowNode, and it is simply available in Ubuntu. In order to install Mosquitto use the following commands: sudo apt-get update -y sudo apt-get install mosquitto mosquitto-clients -y Step 3: Test GrowNode messaging with MQTT Explorer Enable MQTT networking on your GrowNode board, and set in main.c the IP address/nameserver of the machine where you have just installed Mosquitto. Then connect the board to your WiFi network with the provisioning procedure. The instructions for networking and provisioning are here To test the correct reception of MQTT messages from GrowNode, install a MQTT client on the server by opening the \"Ubuntu Software\" application, and searching for and installing \"MQTT Explorer\": You can use any other MQTT client you like to do the test! This is just a simple option already available in Ubuntu. Launch MQTT Explorer, and set localhost both in the \"Name\" and \"Host\" fields, as in figure. Then click on \"SAVE\" and then on \"CONNECT\". The application will start to receive the messages sent by your GrowNode board. Just open the tree of MQTT topics, and you will find them! In the following image you can see the status message sent by the simple blink board that is created in the \"Getting Started\" tutorials . Step 4: Installing openHAB using the official repository To begin, you need to add the openHAB repository to your distribution and then install the latest stable packages (at the time of writing, openHAB 3.2 will be installed): wget -qO - 'https://openhab.jfrog.io/artifactory/api/gpg/key/public' | sudo apt-key add - echo 'deb https://openhab.jfrog.io/artifactory/openhab-linuxpkg stable main' | sudo tee /etc/apt/sources.list.d/openhab.list sudo apt-get update sudo apt-get install openhab openhab-addons Now you can start the openHAB service and check its status (that should be running ): sudo systemctl start openhab.service sudo systemctl status openhab.service Finally, you can register openHAB for starting at startup, so you don't need to start it manually: sudo systemctl daemon-reload sudo systemctl enable openhab.service Step 5: Configuring your first access to openHAB On your workstation, open the address http://localhost:8080/ and a page asking for administrator credentials will appear: Set your admin credentials and log in. Provide language and region information and click on \"Begin Setup\". You can also choose to provide your approximate location, also using the Map tool. Skip the add-ons installation for now. Click on \"Get Started\"... and soon the home page of your openHAB will appear! Congratulations! You successfully installed your own MQTT server and openHAB instance. You will be able to access openHAB from your smartphone using the IP address/server name within your WiFi instead of localhost as address. Soon a tutorial explaining how to link GrowNode to openHAB will be available. Keep in touch!","title":"How to install Mosquitto and openHAB on Ubuntu 18.04 and 20.04 - Easy version"},{"location":"tutorials/openhab_ubuntu1804_2004_easy/#how-to-install-mosquitto-and-openhab-on-ubuntu-1804-and-2004-easy-version","text":"Updated on February 6, 2022","title":"How to install Mosquitto and openHAB on Ubuntu 18.04 and 20.04 - Easy version"},{"location":"tutorials/openhab_ubuntu1804_2004_easy/#introduction","text":"With this step-by-step tutorial you will be able to quickly deploy a message broker and the openHAB automation platform on your Ubuntu 18.04 or 20.04 workstation. How to link openHAB to GrowNode will be tackled in a dedicated tutorial. At the end of the tutorial you will have: installed the Mosquitto MQTT message broker installed a MQTT client tested the reception of messages from GrowNode (if you have a provisioned working board) installed openHAB 3.2 set up your openHAB access Notes: The same steps should also apply for Ubuntu 18.10 and 20.10, but we haven't tried yet. Let us know if you did! Older versions of Ubuntu do not satisfy the minimal requirements out-of-the-box, so they are not officially supported by GrowNode. This procedure could be also used to create an Ubuntu virtual machine to test the openHAB automation server without affecting your main system.","title":"Introduction"},{"location":"tutorials/openhab_ubuntu1804_2004_easy/#disclaimer","text":"Here we describe the basic steps to deploy a demonstrative system that can be used as a starting point. Fine tunings and ad-hoc implementations are out of scope for this document. A proper openHAB installation should be deployed on a machine with a fixed IP within your WiFi network. We assume that you know the IP address/nameserver of your workstation. How to get/fix your IP is out of scope here.","title":"Disclaimer"},{"location":"tutorials/openhab_ubuntu1804_2004_easy/#prerequisites","text":"at least 1.5 Gb free space on hard drive (only for software components, more will be needed to store data retrieved from your GrowNode) at least 4 Gb RAM","title":"Prerequisites"},{"location":"tutorials/openhab_ubuntu1804_2004_easy/#step-1-check-your-java-installation","text":"openHAB 3.2 requires JAVA 11 to run. Newer versions are not supported. You may have already installed JAVA 11 on your system. Check it by running the command: java --version If the command runs and returns a JAVA version equal to 11, you are virtually ok and can move to the next step. However, if you have the standard OpenJDK JAVA on your system, note that openHAB documentation suggests to use the Azul Zulu OpenJDK JAVA 11 package instead. Indeed, OpenJDK is reported to work with some limitations with openHAB. If you have no JAVA 11, or you want to install the recommended Azul Zulu OpenJDK Java 11, refer to the next paragraph.","title":"Step 1: Check your JAVA installation"},{"location":"tutorials/openhab_ubuntu1804_2004_easy/#installing-the-azul-zulu-openjdk-java-11-package","text":"Open the Azul Zulu Download page and download the latest Linux JAVA 11 package for your architecture in .deb format . If you have a standard Linux workstation or virtual machine your architecture is most probably x86 64-bit Open the downloaded file (double click on it) and select \"Install\" in the window that appears... and that's all! :) Check the proper installation with java --version in a terminal.","title":"Installing the Azul Zulu OpenJDK JAVA 11 package"},{"location":"tutorials/openhab_ubuntu1804_2004_easy/#step-2-installing-mosquitto-mqtt-message-broker","text":"Mosquitto is a message broker using the MQTT protocol. GrowNode natively supports MQTT and Mosquitto is a lightweight option to receive all the messages sent by GrowNode, and it is simply available in Ubuntu. In order to install Mosquitto use the following commands: sudo apt-get update -y sudo apt-get install mosquitto mosquitto-clients -y","title":"Step 2: Installing Mosquitto MQTT message broker"},{"location":"tutorials/openhab_ubuntu1804_2004_easy/#step-3-test-grownode-messaging-with-mqtt-explorer","text":"Enable MQTT networking on your GrowNode board, and set in main.c the IP address/nameserver of the machine where you have just installed Mosquitto. Then connect the board to your WiFi network with the provisioning procedure. The instructions for networking and provisioning are here To test the correct reception of MQTT messages from GrowNode, install a MQTT client on the server by opening the \"Ubuntu Software\" application, and searching for and installing \"MQTT Explorer\": You can use any other MQTT client you like to do the test! This is just a simple option already available in Ubuntu. Launch MQTT Explorer, and set localhost both in the \"Name\" and \"Host\" fields, as in figure. Then click on \"SAVE\" and then on \"CONNECT\". The application will start to receive the messages sent by your GrowNode board. Just open the tree of MQTT topics, and you will find them! In the following image you can see the status message sent by the simple blink board that is created in the \"Getting Started\" tutorials .","title":"Step 3: Test GrowNode messaging with MQTT Explorer"},{"location":"tutorials/openhab_ubuntu1804_2004_easy/#step-4-installing-openhab-using-the-official-repository","text":"To begin, you need to add the openHAB repository to your distribution and then install the latest stable packages (at the time of writing, openHAB 3.2 will be installed): wget -qO - 'https://openhab.jfrog.io/artifactory/api/gpg/key/public' | sudo apt-key add - echo 'deb https://openhab.jfrog.io/artifactory/openhab-linuxpkg stable main' | sudo tee /etc/apt/sources.list.d/openhab.list sudo apt-get update sudo apt-get install openhab openhab-addons Now you can start the openHAB service and check its status (that should be running ): sudo systemctl start openhab.service sudo systemctl status openhab.service Finally, you can register openHAB for starting at startup, so you don't need to start it manually: sudo systemctl daemon-reload sudo systemctl enable openhab.service","title":"Step 4: Installing openHAB using the official repository"},{"location":"tutorials/openhab_ubuntu1804_2004_easy/#step-5-configuring-your-first-access-to-openhab","text":"On your workstation, open the address http://localhost:8080/ and a page asking for administrator credentials will appear: Set your admin credentials and log in. Provide language and region information and click on \"Begin Setup\". You can also choose to provide your approximate location, also using the Map tool. Skip the add-ons installation for now. Click on \"Get Started\"... and soon the home page of your openHAB will appear! Congratulations! You successfully installed your own MQTT server and openHAB instance. You will be able to access openHAB from your smartphone using the IP address/server name within your WiFi instead of localhost as address. Soon a tutorial explaining how to link GrowNode to openHAB will be available. Keep in touch!","title":"Step 5: Configuring your first access to openHAB"},{"location":"tutorials/ubuntu1804_2004_advanced/","text":"How to get started with GrowNode on Ubuntu 18.04 and 20.04 - Advanced version Updated on January 18, 2022 Introduction With this step-by-step tutorial you will be able to quickly deploy the GrowNode development environment on your Ubuntu 18.04 or 20.04 workstation. At the end of the tutorial you will have: installed the main packages required to GrowNode installed the ESP-IDF environment v4.4 compiled and run your first GrowNode test board In addition, the following optional steps are also explained: installing the Eclipse IDE installing the ESP-IDF plugin for Eclipse compiling and running your first GrowNode test board via Eclipse Notes: The same steps should also apply for Ubuntu 18.10 and 20.10, but we haven't tried yet. Let us know if you did! Older versions of Ubuntu do not satisfy the minimal requirements out-of-the-box, so they are not officially supported by GrowNode. This procedure could be also used to create an Ubuntu virtual machine to play with GrowNode without affecting your system. Read more details on this in the Appendix below. Prerequisites at least 2.5 Gb free space on hard drive (additional 3 Gb required for Eclipse and related sofrware) at least 4 Gb RAM an ESP32 board with USB cable The ESP32 board could be a ready-to-use one (like the Wemos D1 R32), or other more compact ones that need some soldering (like the ESP32-DevKitC V4 and D1 Mini ESP32). Installing the GrowNode software environment The following steps are mandatory in order to correctly deploy all the software libraries and basic tools for developing a GrowNode board. Just follow the instructions: it will be easy! Step 1: Package installation and system preparation Open a terminal and use the following command to install the main packages required by ESP-IDF: sudo apt-get install git wget flex bison gperf python3 python3-pip python3-setuptools cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0 Then, you can make your serial devices always accessible with: sudo usermod -a -G dialout $USER The latter command becomes effective only once you re-login to your workstation. So, it's better if do a logout/login procedure (or a restart) now to avoid forgetting it :) Step 2: Install the ESP-IDF environment GrowNode needs the environment called ESP-IDF v4.4 to compile the firmware board. Type the following commands to download it in your home and install it in your system: mkdir -p ~/esp cd ~/esp git clone -b release/v4.4 --recursive https://github.com/espressif/esp-idf.git cd ~/esp/esp-idf ./install.sh esp32 echo -e \"\\nalias get_idf='. $HOME/esp/esp-idf/export.sh'\" >> ~/.bashrc source ~/.bashrc Congratulations! You have just installed the base environment that will allow you to build your GrowNode boards! Now you are ready to download and build your first GrowNode project. Step 3: Download the GrowNode source and build the firmware of your first board The following commands allow you to download the current version of GrowNode in your home ESP directory: cd ~/esp git clone --recurse-submodules https://github.com/ogghst/grownode.git It's time for your first build! The first step is setting up the ESP-IDF environment variables. The command is: get_idf IMPORTANT: this operation must be done every time you open a new terminal/console to use ESP-IDF commands, and applies only to that particular console. Now move to GrowNode's folder and build the default project: cd ~/esp/grownode idf.py build The compiler works for a while, and at the end of the process there will be the message Project build complete . If you see a different message... something went wrong. Be sure you followed all the steps above! Step 4: Upload (flash) the firmware on the board After building, plug the ESP32 board to your workstation with an USB cable and detect the name of the new serial port associated to the board. Most probably it is called /dev/ttyUSB0 . If you don't know how to get the name of the new serial port, have a look at the Appendix below Finally, flash your board with the command: cd ~/esp/grownode idf.py -p /dev/ttyUSB0 flash (replace the port name /dev/ttyUSB0 with the one used on your system, if different) Your flash should be fine if at the end of the procedure you see something similar to this: Writing at 0x0000d000... (100 %) Wrote 8192 bytes (31 compressed) at 0x0000d000 in 0.1 seconds (effective 729.6 kbit/s)... Hash of data verified. Leaving... Hard resetting via RTS pin... Done Did you? Great! Have a look at your board: one led is blinking! Congratulations! If you didn't see the above messages and no led is blinking, something went wrong. Assuming you are using the right serial port name, in the official ESP-IDF guide you can find some solutions. A very common problem is serial baud rate, especially if you are working in a virtual machine using VirtualBox. Try to flash using the following command to slow down serial communication: idf.py -p /dev/ttyUSB0 -b 115200 flash (again, replace the port name with yours) Step 5: Monitor the serial output of your board It is possible to read the debug messages sent by the board through the serial port using the following command: idf.py -p /dev/ttyUSB0 monitor (again, replace the port name with yours) If build and flashing were ok, you should see the board continuosly saying something like: I (5602) gn_blink: blinking - 0 I (10602) gn_blink: blinking - 1 Type CTRL+] to exit from the monitor mode. Appendix A. How to get the name of the serial device associated to the ESP32 board The procedure differes depending on if you are working or not inside a virtual machine. Let's see the two cases. If you are NOT working inside a virtual machine In this case, the host serial device associated to the ESP32 board is usually called /dev/ttyUSB0 . If you want to check the actual name, follow these steps: open a terminal plug the USB cable type the command dmesg a line with a text similar to the following should appear at the end of the log, indicating the name of your new serial device in place of your-serial-device-id : usb 1-1: ch341-uart converter now attached to your-serial-device-id use the name /dev/your-serial-device-id when flashing your board or when looking at debug messages through a serial monitor (i.e., in steps 4 and 5 replace /dev/ttyUSB0 with the /dev/your-serial-device-id you discovered here) If you are working inside a virtual machine In this case the serial device depends on the way you set up the virtual machine. If you are using VirtualBox and you followed the instructions below, your serial device will depend on the COM you selected as \"Host Device\": COM1 corresponds to /dev/ttyS0 COM2 corresponds to /dev/ttyS1 ...and so on. B. Installing GrowNode into an Ubuntu virtual machine using VirtualBox If you wish to create a new Ubuntu virtual machine (VM) from scratch using VirtualBox just to have a try of GrowNode without affecting your system, you can still install the software environment inside the VM following the instructions of this page. How to create an Ubuntu VM using VirtualBox is out of scope here. You can find many guides about this topic on the web. When working inside a VM you have to be aware of the following issues/requirements in order to be able to flash and properly work with your board: you must link the host serial device to a VM serial device you must plug the board via USB BEFORE starting the VM you should never unplug the board while the VM is running you will probably need to manually set the flashing baud rate to 115200 baud (as explained at the end of Step 4 above) Properly link the host and guest serial ports In VirtualBox, open the \"Serial Ports\" tab of the VM settings, shown in figure. To properly set the serial communication, you have to: flag \"Enable Serial Port\" select the \"Port Number\" from the list ( COM1 will be ok in most cases) select \"Host Device\" in \"Port Mode\" write the name of the host serial port into the \"Path/Address\" field > Follow the instructions of the previous section \"If you are NOT working inside a virtual machine\" to identify it Installing the Eclipse IDE with the ESP-IDF plugin Eclipse and the ESP-IDF plugin have several requirements which allow one to use only certain versions of softwares and libraries. You have not to worry about this, as this tutorial already makes you install the right things. Step 1: Installing Eclipse IDE for C/C++ Developers 2021-09 This is the latest version officially supported by the plugin, and you can get it following these steps: download it from this page selecting the Linux package that corresponds to your architecture (most probably it is the one called x86_64 ) in the \"Download Links\" column open a terminal and move to the folder where you downloaded the tar.gz file (usually ~/Downloads ) use the following commands to extract Eclipse from the compressed file and make it available for use in the whole system: sudo tar xf eclipse-cpp-2021-09-R-linux-gtk-x86_64.tar.gz -C /opt sudo ln -s /opt/eclipse/eclipse /usr/local/bin/ (optional) if you want to add a desktop icon to avoid launching Eclipse from terminal you need to create a shortcut: open a terminal and launch: sudo nano /usr/share/applications/eclipse.desktop paste the following text into the new empty file and press CTLR+x to save it: [Desktop Entry] Version = 2021-09 Type = Application Terminal = false Name = Eclipse C/C++ Exec = /usr/local/bin/eclipse Icon = /opt/eclipse/icon.xpm Categories = Application; run Eclipse using the command eclipse from a terminal, or by using the Eclipse icon in your desktop (if you created it) at the first start, Eclipse will ask for the default workspace folder. If you followed these instructions, select the esp folder inside your home and then click on \"Launch\" you may also select \"Use this as the default...\" if you are going to use Eclipse only for GrowNode Step 2: Installing the ESP-IDF plugin for Eclipse Once Eclipse is launched, do as follows to install the ESP-IDF plugin: select \"Install New Software\" from the \"Help\" menu click on \"Add...\", a new window opens enter: Name: Espressif IDF Plugin for Eclipse Location: https://dl.espressif.com/dl/idf-eclipse-plugin/updates/latest/ click on \"Add\" select the whole \"Espressif IDF\" tree, as in figure, and then click on \"Next >\" click again on \"Next >\" select \"I accept the terms...\" and then click on \"Finish\" if a warning about unsigned packages appears, click on \"Install anyway\" at the end of the process click on \"Restart Now\" if a sort of error window appears, close it and re-launch Eclipse manually Step 3: Configure Eclipse for using the local ESP-IDF environment Now you are ready to link the ESP-IDF environment you installed at the beginning of this tutorial to Eclipse: select \"Download and Configure ESP-IDF\" in the \"Espressif\" menu check \"Use an existing ESP-IDF directory from the file system\" choose the esp-idf folder you created at the beginning of this tutorial, as in figure click on \"Finish\" click on \"Yes\" in the pop-up window asking to install some new tools in the popup window fill the fields as in figure ESP-IDF Directory: this field should be already filled with the right path Git Executable Location: /usr/bin/git Python Executable Location: /usr/bin/python3 click on \"Install Tools\" and monitor the installation in the status bar at the bottom right Step 4: Import your first GrowNode project and build it Once the tool installation of the previous step is finished, import your first GrowNode project doing: close the \"Welcome\" tab select \"Import...\" from the \"File\" menu select \"Espressif\" > \"Existing IDF Project\" from the list click on \"Browse...\" and select the grownode folder. The field \"Project Name\" will auto-fill with \"grownode\" click on \"Finish\" ...and here you go! GrowNode is imported into Eclipse. Well done! In the Project Explorer on the left you can see the GrowNode workspace: Try your first build by clicking on the hammer icon at the top left, or typing CTRL+B . In the console at the bottom you should see your project compiling and ending with the message Build complete (0 errors... . That means it was successful. Great! Step 5: Flash your board from Eclipse Before flashing you must complete some configuration steps: click on the setting gear beside \"esp32\" in the top icon bar (see point 1 in figure) select the right \"Serial Port\" from the list (the one you identified while installing ESP-IDF, most probably /dev/ttyUSB0 ) and click on \"Finish\" Now plug your board into the USB port and click on the green play icon on the top left, or type CTRL+F11 . Eclipse will start the flashing procedure (it's possible it will re-build the project before) and if everything goes well you should see the following message: Leaving... Hard resetting via RTS pin... Executing action: flash Running ninja in directory /home/your-username-here/esp/grownode/build Executing \"ninja flash\"... Done Did you?! Yes? Perfect! Congratulations! If the answer is no, probably you need to manually set the serial port speed and re-trigger the flashing procedure: click on the setting gear beside \"grownode\" in the top icon bar (see point 2 in the figure above) in the \"Arguments\" section add the following bold parameter exactly in the same position: idf.py -b 115200 -p /dev/your-serial-device-id flash Step 6: Monitor the serial output of your board from Eclipse To start the ESP-IDF monitor click on the icon \"Open a Terminal\" in the top icon bar (see point 1 in figure below). Check the correctness of the serial port and then click on \"Ok\". The board will restart you you will see the \"blinking\" messages. To stop the monitor, just close the \"Terminal\" window or click on the red \"Disconnect Terminal Connection\" at the top right of the terminal itself (point 2 in figure below). Great job! You are ready to play more with GrowNode ;)","title":"How to get started with GrowNode on Ubuntu 18.04 and 20.04 - Advanced version"},{"location":"tutorials/ubuntu1804_2004_advanced/#how-to-get-started-with-grownode-on-ubuntu-1804-and-2004-advanced-version","text":"Updated on January 18, 2022","title":"How to get started with GrowNode on Ubuntu 18.04 and 20.04 - Advanced version"},{"location":"tutorials/ubuntu1804_2004_advanced/#introduction","text":"With this step-by-step tutorial you will be able to quickly deploy the GrowNode development environment on your Ubuntu 18.04 or 20.04 workstation. At the end of the tutorial you will have: installed the main packages required to GrowNode installed the ESP-IDF environment v4.4 compiled and run your first GrowNode test board In addition, the following optional steps are also explained: installing the Eclipse IDE installing the ESP-IDF plugin for Eclipse compiling and running your first GrowNode test board via Eclipse Notes: The same steps should also apply for Ubuntu 18.10 and 20.10, but we haven't tried yet. Let us know if you did! Older versions of Ubuntu do not satisfy the minimal requirements out-of-the-box, so they are not officially supported by GrowNode. This procedure could be also used to create an Ubuntu virtual machine to play with GrowNode without affecting your system. Read more details on this in the Appendix below.","title":"Introduction"},{"location":"tutorials/ubuntu1804_2004_advanced/#prerequisites","text":"at least 2.5 Gb free space on hard drive (additional 3 Gb required for Eclipse and related sofrware) at least 4 Gb RAM an ESP32 board with USB cable The ESP32 board could be a ready-to-use one (like the Wemos D1 R32), or other more compact ones that need some soldering (like the ESP32-DevKitC V4 and D1 Mini ESP32).","title":"Prerequisites"},{"location":"tutorials/ubuntu1804_2004_advanced/#installing-the-grownode-software-environment","text":"The following steps are mandatory in order to correctly deploy all the software libraries and basic tools for developing a GrowNode board. Just follow the instructions: it will be easy!","title":"Installing the GrowNode software environment"},{"location":"tutorials/ubuntu1804_2004_advanced/#step-1-package-installation-and-system-preparation","text":"Open a terminal and use the following command to install the main packages required by ESP-IDF: sudo apt-get install git wget flex bison gperf python3 python3-pip python3-setuptools cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0 Then, you can make your serial devices always accessible with: sudo usermod -a -G dialout $USER The latter command becomes effective only once you re-login to your workstation. So, it's better if do a logout/login procedure (or a restart) now to avoid forgetting it :)","title":"Step 1: Package installation and system preparation"},{"location":"tutorials/ubuntu1804_2004_advanced/#step-2-install-the-esp-idf-environment","text":"GrowNode needs the environment called ESP-IDF v4.4 to compile the firmware board. Type the following commands to download it in your home and install it in your system: mkdir -p ~/esp cd ~/esp git clone -b release/v4.4 --recursive https://github.com/espressif/esp-idf.git cd ~/esp/esp-idf ./install.sh esp32 echo -e \"\\nalias get_idf='. $HOME/esp/esp-idf/export.sh'\" >> ~/.bashrc source ~/.bashrc Congratulations! You have just installed the base environment that will allow you to build your GrowNode boards! Now you are ready to download and build your first GrowNode project.","title":"Step 2: Install the ESP-IDF environment"},{"location":"tutorials/ubuntu1804_2004_advanced/#step-3-download-the-grownode-source-and-build-the-firmware-of-your-first-board","text":"The following commands allow you to download the current version of GrowNode in your home ESP directory: cd ~/esp git clone --recurse-submodules https://github.com/ogghst/grownode.git It's time for your first build! The first step is setting up the ESP-IDF environment variables. The command is: get_idf IMPORTANT: this operation must be done every time you open a new terminal/console to use ESP-IDF commands, and applies only to that particular console. Now move to GrowNode's folder and build the default project: cd ~/esp/grownode idf.py build The compiler works for a while, and at the end of the process there will be the message Project build complete . If you see a different message... something went wrong. Be sure you followed all the steps above!","title":"Step 3: Download the GrowNode source and build the firmware of your first board"},{"location":"tutorials/ubuntu1804_2004_advanced/#step-4-upload-flash-the-firmware-on-the-board","text":"After building, plug the ESP32 board to your workstation with an USB cable and detect the name of the new serial port associated to the board. Most probably it is called /dev/ttyUSB0 . If you don't know how to get the name of the new serial port, have a look at the Appendix below Finally, flash your board with the command: cd ~/esp/grownode idf.py -p /dev/ttyUSB0 flash (replace the port name /dev/ttyUSB0 with the one used on your system, if different) Your flash should be fine if at the end of the procedure you see something similar to this: Writing at 0x0000d000... (100 %) Wrote 8192 bytes (31 compressed) at 0x0000d000 in 0.1 seconds (effective 729.6 kbit/s)... Hash of data verified. Leaving... Hard resetting via RTS pin... Done Did you? Great! Have a look at your board: one led is blinking! Congratulations! If you didn't see the above messages and no led is blinking, something went wrong. Assuming you are using the right serial port name, in the official ESP-IDF guide you can find some solutions. A very common problem is serial baud rate, especially if you are working in a virtual machine using VirtualBox. Try to flash using the following command to slow down serial communication: idf.py -p /dev/ttyUSB0 -b 115200 flash (again, replace the port name with yours)","title":"Step 4: Upload (flash) the firmware on the board"},{"location":"tutorials/ubuntu1804_2004_advanced/#step-5-monitor-the-serial-output-of-your-board","text":"It is possible to read the debug messages sent by the board through the serial port using the following command: idf.py -p /dev/ttyUSB0 monitor (again, replace the port name with yours) If build and flashing were ok, you should see the board continuosly saying something like: I (5602) gn_blink: blinking - 0 I (10602) gn_blink: blinking - 1 Type CTRL+] to exit from the monitor mode.","title":"Step 5: Monitor the serial output of your board"},{"location":"tutorials/ubuntu1804_2004_advanced/#appendix","text":"","title":"Appendix"},{"location":"tutorials/ubuntu1804_2004_advanced/#a-how-to-get-the-name-of-the-serial-device-associated-to-the-esp32-board","text":"The procedure differes depending on if you are working or not inside a virtual machine. Let's see the two cases.","title":"A. How to get the name of the serial device associated to the ESP32 board"},{"location":"tutorials/ubuntu1804_2004_advanced/#if-you-are-not-working-inside-a-virtual-machine","text":"In this case, the host serial device associated to the ESP32 board is usually called /dev/ttyUSB0 . If you want to check the actual name, follow these steps: open a terminal plug the USB cable type the command dmesg a line with a text similar to the following should appear at the end of the log, indicating the name of your new serial device in place of your-serial-device-id : usb 1-1: ch341-uart converter now attached to your-serial-device-id use the name /dev/your-serial-device-id when flashing your board or when looking at debug messages through a serial monitor (i.e., in steps 4 and 5 replace /dev/ttyUSB0 with the /dev/your-serial-device-id you discovered here)","title":"If you are NOT working inside a virtual machine"},{"location":"tutorials/ubuntu1804_2004_advanced/#if-you-are-working-inside-a-virtual-machine","text":"In this case the serial device depends on the way you set up the virtual machine. If you are using VirtualBox and you followed the instructions below, your serial device will depend on the COM you selected as \"Host Device\": COM1 corresponds to /dev/ttyS0 COM2 corresponds to /dev/ttyS1 ...and so on.","title":"If you are working inside a virtual machine"},{"location":"tutorials/ubuntu1804_2004_advanced/#b-installing-grownode-into-an-ubuntu-virtual-machine-using-virtualbox","text":"If you wish to create a new Ubuntu virtual machine (VM) from scratch using VirtualBox just to have a try of GrowNode without affecting your system, you can still install the software environment inside the VM following the instructions of this page. How to create an Ubuntu VM using VirtualBox is out of scope here. You can find many guides about this topic on the web. When working inside a VM you have to be aware of the following issues/requirements in order to be able to flash and properly work with your board: you must link the host serial device to a VM serial device you must plug the board via USB BEFORE starting the VM you should never unplug the board while the VM is running you will probably need to manually set the flashing baud rate to 115200 baud (as explained at the end of Step 4 above)","title":"B. Installing GrowNode into an Ubuntu virtual machine using VirtualBox"},{"location":"tutorials/ubuntu1804_2004_advanced/#properly-link-the-host-and-guest-serial-ports","text":"In VirtualBox, open the \"Serial Ports\" tab of the VM settings, shown in figure. To properly set the serial communication, you have to: flag \"Enable Serial Port\" select the \"Port Number\" from the list ( COM1 will be ok in most cases) select \"Host Device\" in \"Port Mode\" write the name of the host serial port into the \"Path/Address\" field > Follow the instructions of the previous section \"If you are NOT working inside a virtual machine\" to identify it","title":"Properly link the host and guest serial ports"},{"location":"tutorials/ubuntu1804_2004_advanced/#installing-the-eclipse-ide-with-the-esp-idf-plugin","text":"Eclipse and the ESP-IDF plugin have several requirements which allow one to use only certain versions of softwares and libraries. You have not to worry about this, as this tutorial already makes you install the right things.","title":"Installing the Eclipse IDE with the ESP-IDF plugin"},{"location":"tutorials/ubuntu1804_2004_advanced/#step-1-installing-eclipse-ide-for-cc-developers-2021-09","text":"This is the latest version officially supported by the plugin, and you can get it following these steps: download it from this page selecting the Linux package that corresponds to your architecture (most probably it is the one called x86_64 ) in the \"Download Links\" column open a terminal and move to the folder where you downloaded the tar.gz file (usually ~/Downloads ) use the following commands to extract Eclipse from the compressed file and make it available for use in the whole system: sudo tar xf eclipse-cpp-2021-09-R-linux-gtk-x86_64.tar.gz -C /opt sudo ln -s /opt/eclipse/eclipse /usr/local/bin/ (optional) if you want to add a desktop icon to avoid launching Eclipse from terminal you need to create a shortcut: open a terminal and launch: sudo nano /usr/share/applications/eclipse.desktop paste the following text into the new empty file and press CTLR+x to save it: [Desktop Entry] Version = 2021-09 Type = Application Terminal = false Name = Eclipse C/C++ Exec = /usr/local/bin/eclipse Icon = /opt/eclipse/icon.xpm Categories = Application; run Eclipse using the command eclipse from a terminal, or by using the Eclipse icon in your desktop (if you created it) at the first start, Eclipse will ask for the default workspace folder. If you followed these instructions, select the esp folder inside your home and then click on \"Launch\" you may also select \"Use this as the default...\" if you are going to use Eclipse only for GrowNode","title":"Step 1: Installing Eclipse IDE for C/C++ Developers 2021-09"},{"location":"tutorials/ubuntu1804_2004_advanced/#step-2-installing-the-esp-idf-plugin-for-eclipse","text":"Once Eclipse is launched, do as follows to install the ESP-IDF plugin: select \"Install New Software\" from the \"Help\" menu click on \"Add...\", a new window opens enter: Name: Espressif IDF Plugin for Eclipse Location: https://dl.espressif.com/dl/idf-eclipse-plugin/updates/latest/ click on \"Add\" select the whole \"Espressif IDF\" tree, as in figure, and then click on \"Next >\" click again on \"Next >\" select \"I accept the terms...\" and then click on \"Finish\" if a warning about unsigned packages appears, click on \"Install anyway\" at the end of the process click on \"Restart Now\" if a sort of error window appears, close it and re-launch Eclipse manually","title":"Step 2: Installing the ESP-IDF plugin for Eclipse"},{"location":"tutorials/ubuntu1804_2004_advanced/#step-3-configure-eclipse-for-using-the-local-esp-idf-environment","text":"Now you are ready to link the ESP-IDF environment you installed at the beginning of this tutorial to Eclipse: select \"Download and Configure ESP-IDF\" in the \"Espressif\" menu check \"Use an existing ESP-IDF directory from the file system\" choose the esp-idf folder you created at the beginning of this tutorial, as in figure click on \"Finish\" click on \"Yes\" in the pop-up window asking to install some new tools in the popup window fill the fields as in figure ESP-IDF Directory: this field should be already filled with the right path Git Executable Location: /usr/bin/git Python Executable Location: /usr/bin/python3 click on \"Install Tools\" and monitor the installation in the status bar at the bottom right","title":"Step 3: Configure Eclipse for using the local ESP-IDF environment"},{"location":"tutorials/ubuntu1804_2004_advanced/#step-4-import-your-first-grownode-project-and-build-it","text":"Once the tool installation of the previous step is finished, import your first GrowNode project doing: close the \"Welcome\" tab select \"Import...\" from the \"File\" menu select \"Espressif\" > \"Existing IDF Project\" from the list click on \"Browse...\" and select the grownode folder. The field \"Project Name\" will auto-fill with \"grownode\" click on \"Finish\" ...and here you go! GrowNode is imported into Eclipse. Well done! In the Project Explorer on the left you can see the GrowNode workspace: Try your first build by clicking on the hammer icon at the top left, or typing CTRL+B . In the console at the bottom you should see your project compiling and ending with the message Build complete (0 errors... . That means it was successful. Great!","title":"Step 4: Import your first GrowNode project and build it"},{"location":"tutorials/ubuntu1804_2004_advanced/#step-5-flash-your-board-from-eclipse","text":"Before flashing you must complete some configuration steps: click on the setting gear beside \"esp32\" in the top icon bar (see point 1 in figure) select the right \"Serial Port\" from the list (the one you identified while installing ESP-IDF, most probably /dev/ttyUSB0 ) and click on \"Finish\" Now plug your board into the USB port and click on the green play icon on the top left, or type CTRL+F11 . Eclipse will start the flashing procedure (it's possible it will re-build the project before) and if everything goes well you should see the following message: Leaving... Hard resetting via RTS pin... Executing action: flash Running ninja in directory /home/your-username-here/esp/grownode/build Executing \"ninja flash\"... Done Did you?! Yes? Perfect! Congratulations! If the answer is no, probably you need to manually set the serial port speed and re-trigger the flashing procedure: click on the setting gear beside \"grownode\" in the top icon bar (see point 2 in the figure above) in the \"Arguments\" section add the following bold parameter exactly in the same position: idf.py -b 115200 -p /dev/your-serial-device-id flash","title":"Step 5: Flash your board from Eclipse"},{"location":"tutorials/ubuntu1804_2004_advanced/#step-6-monitor-the-serial-output-of-your-board-from-eclipse","text":"To start the ESP-IDF monitor click on the icon \"Open a Terminal\" in the top icon bar (see point 1 in figure below). Check the correctness of the serial port and then click on \"Ok\". The board will restart you you will see the \"blinking\" messages. To stop the monitor, just close the \"Terminal\" window or click on the red \"Disconnect Terminal Connection\" at the top right of the terminal itself (point 2 in figure below). Great job! You are ready to play more with GrowNode ;)","title":"Step 6: Monitor the serial output of your board from Eclipse"},{"location":"tutorials/ubuntu1804_2004_easy/","text":"How to get started with GrowNode on Ubuntu 18.04 and 20.04 - Easy version Updated on January 18, 2022 Introduction With this step-by-step tutorial you will be able to quickly deploy the Eclipse IDE with the GrowNode development environment on your Ubuntu 18.04 or 20.04 workstation. At the end of the tutorial you will have: installed the Eclipse IDE installed the ESP-IDF plugin for Eclipse installed the main packages required to GrowNode installed the latest ESP-IDF environment compiled and run your first GrowNode test board via Eclipse Notes: The same steps should also apply for Ubuntu 18.10 and 20.10, but we haven't tried yet. Let us know if you did! Older versions of Ubuntu do not satisfy the minimal requirements out-of-the-box, so they are not officially supported by GrowNode. This procedure could be also used to create an Ubuntu virtual machine to play with GrowNode without affecting your system. Read more details on this in the Appendix below. Prerequisites at least 5.5 Gb free space on hard drive at least 4 Gb RAM an ESP32 board with USB cable The ESP32 board could be a ready-to-use one (like the Wemos D1 R32), or other more compact ones that need some soldering (like the ESP32-DevKitC V4 and D1 Mini ESP32). Step 1: Prepare your system Before starting installing any software, you need to prepare your system downloading some basic packages. Open a terminal and type this commands: sudo apt-get install git wget flex bison gperf python3 python3-pip python3-setuptools cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0 mkdir -p ~/esp Then, you can make your serial devices always accessible with: sudo usermod -a -G dialout $USER The latter command becomes effective only once you re-login to your workstation. So, it's better if do a logout/login procedure (or a restart) now to avoid forgetting it :) Step 2: Installing Eclipse IDE for C/C++ Developers 2021-09 This is the latest version officially supported by the plugin, and you can get it following these steps: download it from this page selecting the Linux package that corresponds to your architecture (most probably it is the one called x86_64 ) in the \"Download Links\" column open a terminal and move to the folder where you downloaded the tar.gz file (usually ~/Downloads ) use the following commands to extract Eclipse from the compressed file and make it available for use in the whole system: sudo tar xf eclipse-cpp-2021-09-R-linux-gtk-x86_64.tar.gz -C /opt sudo ln -s /opt/eclipse/eclipse /usr/local/bin/ (optional) if you want to add a desktop icon to avoid launching Eclipse from terminal you need to create a shortcut: open a terminal and launch: sudo nano /usr/share/applications/eclipse.desktop paste the following text into the new empty file and press CTLR+x to save it: [Desktop Entry] Version = 2021-09 Type = Application Terminal = false Name = Eclipse C/C++ Exec = /usr/local/bin/eclipse Icon = /opt/eclipse/icon.xpm Categories = Application; run Eclipse using the command eclipse from a terminal, or by using the Eclipse icon in your desktop (if you created it) at the first start, Eclipse will ask for the default workspace folder. Click on \"Browse...\", select the folder called esp inside your home, click on \"Open\" and then on \"Launch\" you may also select \"Use this as the default...\" if you are going to use Eclipse only for GrowNode Step 3: Installing the ESP-IDF plugin for Eclipse Once Eclipse is launched, do as follows to install the ESP-IDF plugin: close the \"Welcome\" tab select \"Install New Software\" from the \"Help\" menu click on \"Add...\", a new window opens enter: Name: Espressif IDF Plugin for Eclipse Location: https://dl.espressif.com/dl/idf-eclipse-plugin/updates/latest/ click on \"Add\" select the whole \"Espressif IDF\" tree, as in figure, and then click on \"Next >\" click again on \"Next >\" select \"I accept the terms...\" and then click on \"Finish\" if a warning about unsigned packages appears, click on \"Install anyway\" at the end of the process click on \"Restart Now\" if a sort of error window appears, close it and re-launch Eclipse manually Step 4: Download the ESP-IDF environment from Eclipse Now you are ready to download the ESP-IDF environment from Eclipse: select \"Download and Configure ESP-IDF\" in the \"Espressif\" menu in the \"Download ESP-IDF\" box select the \"master\" version and the folder esp you created before, as in figure click on \"Finish\" in the Console area you will see the status of ESP-IDF download when the download is ended, click on \"Yes\" in the pop-up window asking to install some new tools in the popup window fill the fields as in figure ESP-IDF Directory: this field should be already filled with the right path Git Executable Location: /usr/bin/git Python Executable Location: /usr/bin/python3 click on \"Install Tools\" and monitor the installation in the status bar at the bottom right Step 5: Download GrowNode and build it Once the tool installation of the previous step is finished, import your first GrowNode project doing: select \"Import...\" from the \"File\" menu select \"Git\" > \"Projects from Git\" from the list and click on \"Next >\" select \"Clone URI\" from the list and click on \"Next >\" fill the field \"URI\" with https://github.com/ogghst/grownode.git and the remaining fields will auto-complete, as in figure, and click on \"Next >\" unless you are interested in other branches, select only the \"master\" branch, as in figure, and then click on \"Next >\" (with smart import) change the \"Directory\" field setting a grownode folder inside the esp folder you created before and flag the \"Clone submodules\" option, as in figure; click on \"Next >\" click on \"Next >\" in the following window, leaving unchanged the selection of \"Import existing Eclipse projects\" unless you are interested in other projects, select only the grownode project from the list, as in figure, and click on \"Finish\" ...and here you go! GrowNode is imported into Eclipse. Well done! In the Project Explorer on the left you can see the GrowNode workspace: Try your first build by clicking on the hammer icon at the top left, or typing CTRL+B . In the console at the bottom you should see your project compiling and ending with the message Build complete (0 errors... . That means it was successful. Great! Step 6: Flash your board from Eclipse Before flashing you must complete some configuration steps: click on the setting gear beside \"esp32\" in the top icon bar (see point 1 in figure) < ../img alt=\"ESP32 serial port in Eclipse\" src=\"img/eclipse_flashing_settings.png\"> select the right \"Serial Port\" from the list (the one you identified while installing ESP-IDF, most probably /dev/ttyUSB0 ) and click on \"Finish\" Now plug your board into the USB port and click on the green play icon on the top left, or type CTRL+F11 . Eclipse will start the flashing procedure (it's possible it will re-build the project before) and if everything goes well you should see the following message: Leaving... Hard resetting via RTS pin... Executing action: flash Running ninja in directory /home/your-username-here/esp/grownode/build Executing \"ninja flash\"... Did you?! Yes? Perfect! Congratulations! If the answer is no, probably you need to manually set the serial port speed and re-trigger the flashing procedure: click on the setting gear beside \"grownode\" in the top icon bar (see point 2 in the figure above) in the \"Arguments\" section add the following bold parameter exactly in the same position: idf.py -b 115200 -p /dev/your-serial-device-id flash Step 7: Monitor the serial output of your board from Eclipse To start the ESP-IDF monitor click on the icon \"Open a Terminal\" in the top icon bar (see point 1 in figure below). Check the correctness of the serial port and then click on \"Ok\". The board will restart you you will see the \"blinking\" messages. To stop the monitor, just close the \"Terminal\" window or click on the red \"Disconnect Terminal Connection\" at the top right of the terminal itself (point 2 in figure below). Great job! You are ready to play more with GrowNode ;) Appendix A. How to get the name of the serial device associated to the ESP32 board The procedure differes depending on if you are working or not inside a virtual machine. Let's see the two cases. If you are NOT working inside a virtual machine In this case, the host serial device associated to the ESP32 board is usually called /dev/ttyUSB0 . If you want to check the actual name, follow these steps: open a terminal plug the USB cable type the command dmesg a line with a text similar to the following should appear at the end of the log, indicating the name of your new serial device in place of your-serial-device-id : usb 1-1: ch341-uart converter now attached to your-serial-device-id use the name /dev/your-serial-device-id when flashing your board or when looking at debug messages through a serial monitor (i.e., in steps 4 and 5 replace /dev/ttyUSB0 with the /dev/your-serial-device-id you discovered here) If you are working inside a virtual machine In this case the serial device depends on the way you set up the virtual machine. If you are using VirtualBox and you followed the instructions below, your serial device will depend on the COM you selected as \"Host Device\": COM1 corresponds to /dev/ttyS0 COM2 corresponds to /dev/ttyS1 ...and so on. B. Installing GrowNode into an Ubuntu virtual machine using VirtualBox If you wish to create a new Ubuntu virtual machine (VM) from scratch using VirtualBox just to have a try of GrowNode without affecting your system, you can still install the software environment inside the VM following the instructions of this page. How to create an Ubuntu VM using VirtualBox is out of scope here. You can find many guides about this topic on the web. When working inside a VM you have to be aware of the following issues/requirements in order to be able to flash and properly work with your board: you must link the host serial device to a VM serial device you must plug the board via USB BEFORE starting the VM you should never unplug the board while the VM is running you will probably need to manually set the flashing baud rate to 115200 baud (as explained at the end of Step 4 above) Properly link the host and guest serial ports In VirtualBox, open the \"Serial Ports\" tab of the VM settings, shown in figure. To properly set the serial communication, you have to: flag \"Enable Serial Port\" select the \"Port Number\" from the list ( COM1 will be ok in most cases) select \"Host Device\" in \"Port Mode\" write the name of the host serial port into the \"Path/Address\" field > Follow the instructions of the previous section \"If you are NOT working inside a virtual machine\" to identify it","title":"How to get started with GrowNode on Ubuntu 18.04 and 20.04 - Easy version"},{"location":"tutorials/ubuntu1804_2004_easy/#how-to-get-started-with-grownode-on-ubuntu-1804-and-2004-easy-version","text":"Updated on January 18, 2022","title":"How to get started with GrowNode on Ubuntu 18.04 and 20.04 - Easy version"},{"location":"tutorials/ubuntu1804_2004_easy/#introduction","text":"With this step-by-step tutorial you will be able to quickly deploy the Eclipse IDE with the GrowNode development environment on your Ubuntu 18.04 or 20.04 workstation. At the end of the tutorial you will have: installed the Eclipse IDE installed the ESP-IDF plugin for Eclipse installed the main packages required to GrowNode installed the latest ESP-IDF environment compiled and run your first GrowNode test board via Eclipse Notes: The same steps should also apply for Ubuntu 18.10 and 20.10, but we haven't tried yet. Let us know if you did! Older versions of Ubuntu do not satisfy the minimal requirements out-of-the-box, so they are not officially supported by GrowNode. This procedure could be also used to create an Ubuntu virtual machine to play with GrowNode without affecting your system. Read more details on this in the Appendix below.","title":"Introduction"},{"location":"tutorials/ubuntu1804_2004_easy/#prerequisites","text":"at least 5.5 Gb free space on hard drive at least 4 Gb RAM an ESP32 board with USB cable The ESP32 board could be a ready-to-use one (like the Wemos D1 R32), or other more compact ones that need some soldering (like the ESP32-DevKitC V4 and D1 Mini ESP32).","title":"Prerequisites"},{"location":"tutorials/ubuntu1804_2004_easy/#step-1-prepare-your-system","text":"Before starting installing any software, you need to prepare your system downloading some basic packages. Open a terminal and type this commands: sudo apt-get install git wget flex bison gperf python3 python3-pip python3-setuptools cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0 mkdir -p ~/esp Then, you can make your serial devices always accessible with: sudo usermod -a -G dialout $USER The latter command becomes effective only once you re-login to your workstation. So, it's better if do a logout/login procedure (or a restart) now to avoid forgetting it :)","title":"Step 1: Prepare your system"},{"location":"tutorials/ubuntu1804_2004_easy/#step-2-installing-eclipse-ide-for-cc-developers-2021-09","text":"This is the latest version officially supported by the plugin, and you can get it following these steps: download it from this page selecting the Linux package that corresponds to your architecture (most probably it is the one called x86_64 ) in the \"Download Links\" column open a terminal and move to the folder where you downloaded the tar.gz file (usually ~/Downloads ) use the following commands to extract Eclipse from the compressed file and make it available for use in the whole system: sudo tar xf eclipse-cpp-2021-09-R-linux-gtk-x86_64.tar.gz -C /opt sudo ln -s /opt/eclipse/eclipse /usr/local/bin/ (optional) if you want to add a desktop icon to avoid launching Eclipse from terminal you need to create a shortcut: open a terminal and launch: sudo nano /usr/share/applications/eclipse.desktop paste the following text into the new empty file and press CTLR+x to save it: [Desktop Entry] Version = 2021-09 Type = Application Terminal = false Name = Eclipse C/C++ Exec = /usr/local/bin/eclipse Icon = /opt/eclipse/icon.xpm Categories = Application; run Eclipse using the command eclipse from a terminal, or by using the Eclipse icon in your desktop (if you created it) at the first start, Eclipse will ask for the default workspace folder. Click on \"Browse...\", select the folder called esp inside your home, click on \"Open\" and then on \"Launch\" you may also select \"Use this as the default...\" if you are going to use Eclipse only for GrowNode","title":"Step 2: Installing Eclipse IDE for C/C++ Developers 2021-09"},{"location":"tutorials/ubuntu1804_2004_easy/#step-3-installing-the-esp-idf-plugin-for-eclipse","text":"Once Eclipse is launched, do as follows to install the ESP-IDF plugin: close the \"Welcome\" tab select \"Install New Software\" from the \"Help\" menu click on \"Add...\", a new window opens enter: Name: Espressif IDF Plugin for Eclipse Location: https://dl.espressif.com/dl/idf-eclipse-plugin/updates/latest/ click on \"Add\" select the whole \"Espressif IDF\" tree, as in figure, and then click on \"Next >\" click again on \"Next >\" select \"I accept the terms...\" and then click on \"Finish\" if a warning about unsigned packages appears, click on \"Install anyway\" at the end of the process click on \"Restart Now\" if a sort of error window appears, close it and re-launch Eclipse manually","title":"Step 3: Installing the ESP-IDF plugin for Eclipse"},{"location":"tutorials/ubuntu1804_2004_easy/#step-4-download-the-esp-idf-environment-from-eclipse","text":"Now you are ready to download the ESP-IDF environment from Eclipse: select \"Download and Configure ESP-IDF\" in the \"Espressif\" menu in the \"Download ESP-IDF\" box select the \"master\" version and the folder esp you created before, as in figure click on \"Finish\" in the Console area you will see the status of ESP-IDF download when the download is ended, click on \"Yes\" in the pop-up window asking to install some new tools in the popup window fill the fields as in figure ESP-IDF Directory: this field should be already filled with the right path Git Executable Location: /usr/bin/git Python Executable Location: /usr/bin/python3 click on \"Install Tools\" and monitor the installation in the status bar at the bottom right","title":"Step 4: Download the ESP-IDF environment from Eclipse"},{"location":"tutorials/ubuntu1804_2004_easy/#step-5-download-grownode-and-build-it","text":"Once the tool installation of the previous step is finished, import your first GrowNode project doing: select \"Import...\" from the \"File\" menu select \"Git\" > \"Projects from Git\" from the list and click on \"Next >\" select \"Clone URI\" from the list and click on \"Next >\" fill the field \"URI\" with https://github.com/ogghst/grownode.git and the remaining fields will auto-complete, as in figure, and click on \"Next >\" unless you are interested in other branches, select only the \"master\" branch, as in figure, and then click on \"Next >\" (with smart import) change the \"Directory\" field setting a grownode folder inside the esp folder you created before and flag the \"Clone submodules\" option, as in figure; click on \"Next >\" click on \"Next >\" in the following window, leaving unchanged the selection of \"Import existing Eclipse projects\" unless you are interested in other projects, select only the grownode project from the list, as in figure, and click on \"Finish\" ...and here you go! GrowNode is imported into Eclipse. Well done! In the Project Explorer on the left you can see the GrowNode workspace: Try your first build by clicking on the hammer icon at the top left, or typing CTRL+B . In the console at the bottom you should see your project compiling and ending with the message Build complete (0 errors... . That means it was successful. Great!","title":"Step 5: Download GrowNode and build it"},{"location":"tutorials/ubuntu1804_2004_easy/#step-6-flash-your-board-from-eclipse","text":"Before flashing you must complete some configuration steps: click on the setting gear beside \"esp32\" in the top icon bar (see point 1 in figure) < ../img alt=\"ESP32 serial port in Eclipse\" src=\"img/eclipse_flashing_settings.png\"> select the right \"Serial Port\" from the list (the one you identified while installing ESP-IDF, most probably /dev/ttyUSB0 ) and click on \"Finish\" Now plug your board into the USB port and click on the green play icon on the top left, or type CTRL+F11 . Eclipse will start the flashing procedure (it's possible it will re-build the project before) and if everything goes well you should see the following message: Leaving... Hard resetting via RTS pin... Executing action: flash Running ninja in directory /home/your-username-here/esp/grownode/build Executing \"ninja flash\"... Did you?! Yes? Perfect! Congratulations! If the answer is no, probably you need to manually set the serial port speed and re-trigger the flashing procedure: click on the setting gear beside \"grownode\" in the top icon bar (see point 2 in the figure above) in the \"Arguments\" section add the following bold parameter exactly in the same position: idf.py -b 115200 -p /dev/your-serial-device-id flash","title":"Step 6: Flash your board from Eclipse"},{"location":"tutorials/ubuntu1804_2004_easy/#step-7-monitor-the-serial-output-of-your-board-from-eclipse","text":"To start the ESP-IDF monitor click on the icon \"Open a Terminal\" in the top icon bar (see point 1 in figure below). Check the correctness of the serial port and then click on \"Ok\". The board will restart you you will see the \"blinking\" messages. To stop the monitor, just close the \"Terminal\" window or click on the red \"Disconnect Terminal Connection\" at the top right of the terminal itself (point 2 in figure below). Great job! You are ready to play more with GrowNode ;)","title":"Step 7: Monitor the serial output of your board from Eclipse"},{"location":"tutorials/ubuntu1804_2004_easy/#appendix","text":"","title":"Appendix"},{"location":"tutorials/ubuntu1804_2004_easy/#a-how-to-get-the-name-of-the-serial-device-associated-to-the-esp32-board","text":"The procedure differes depending on if you are working or not inside a virtual machine. Let's see the two cases.","title":"A. How to get the name of the serial device associated to the ESP32 board"},{"location":"tutorials/ubuntu1804_2004_easy/#if-you-are-not-working-inside-a-virtual-machine","text":"In this case, the host serial device associated to the ESP32 board is usually called /dev/ttyUSB0 . If you want to check the actual name, follow these steps: open a terminal plug the USB cable type the command dmesg a line with a text similar to the following should appear at the end of the log, indicating the name of your new serial device in place of your-serial-device-id : usb 1-1: ch341-uart converter now attached to your-serial-device-id use the name /dev/your-serial-device-id when flashing your board or when looking at debug messages through a serial monitor (i.e., in steps 4 and 5 replace /dev/ttyUSB0 with the /dev/your-serial-device-id you discovered here)","title":"If you are NOT working inside a virtual machine"},{"location":"tutorials/ubuntu1804_2004_easy/#if-you-are-working-inside-a-virtual-machine","text":"In this case the serial device depends on the way you set up the virtual machine. If you are using VirtualBox and you followed the instructions below, your serial device will depend on the COM you selected as \"Host Device\": COM1 corresponds to /dev/ttyS0 COM2 corresponds to /dev/ttyS1 ...and so on.","title":"If you are working inside a virtual machine"},{"location":"tutorials/ubuntu1804_2004_easy/#b-installing-grownode-into-an-ubuntu-virtual-machine-using-virtualbox","text":"If you wish to create a new Ubuntu virtual machine (VM) from scratch using VirtualBox just to have a try of GrowNode without affecting your system, you can still install the software environment inside the VM following the instructions of this page. How to create an Ubuntu VM using VirtualBox is out of scope here. You can find many guides about this topic on the web. When working inside a VM you have to be aware of the following issues/requirements in order to be able to flash and properly work with your board: you must link the host serial device to a VM serial device you must plug the board via USB BEFORE starting the VM you should never unplug the board while the VM is running you will probably need to manually set the flashing baud rate to 115200 baud (as explained at the end of Step 4 above)","title":"B. Installing GrowNode into an Ubuntu virtual machine using VirtualBox"},{"location":"tutorials/ubuntu1804_2004_easy/#properly-link-the-host-and-guest-serial-ports","text":"In VirtualBox, open the \"Serial Ports\" tab of the VM settings, shown in figure. To properly set the serial communication, you have to: flag \"Enable Serial Port\" select the \"Port Number\" from the list ( COM1 will be ok in most cases) select \"Host Device\" in \"Port Mode\" write the name of the host serial port into the \"Path/Address\" field > Follow the instructions of the previous section \"If you are NOT working inside a virtual machine\" to identify it","title":"Properly link the host and guest serial ports"},{"location":"tutorials/windows10_11_easy/","text":"How to get started with GrowNode on Windows 10 and Windows 11 - Easy version Updated on January 21, 2022 Introduction With this step-by-step tutorial you will be able to quickly deploy the Eclipse IDE with the GrowNode development environment on your Windows 10/11 workstation. Despite the whole process is very simple, at the end of the tutorial you will have: installed the Eclipse IDE installed the ESP-IDF plugin for Eclipse installed the latest ESP-IDFv4.4 environment compiled and run your first GrowNode test board via Eclipse Notes: Only 64 bit operating systems are supported The same steps should also apply for Windows 7 64 bit, but we haven't tried yet. Let us know if you did! This procedure could be also used to create a Windows virtual machine to play with GrowNode without affecting your system. Read more details on this in the Appendix below. Prerequisites at least 6.5 Gb free space on hard drive at least 4 Gb RAM an ESP32 board with USB cable The ESP32 board could be a ready-to-use one (like the Wemos D1 R32), or other more compact ones that need some soldering (like the ESP32-DevKitC V4 and D1 Mini ESP32). Step 1: Download and run the ESP-IDF online installer Download the ESP-IDF online installer from https://dl.espressif.com/dl/esp-idf/?idf=4.4 The online installer is a small program that triggers the download of the needed software. Alternatively, if you need to install the GrowNode environment on a machine without internet connection, you can also download the offline installer. Run the installer, accept the terms and conditions, and follow these steps: if suggested, click on \"Apply Fixes\" in the \"Pre-installation system check\" window (this requires Administrator rights, which you probably have, and will open another window asking for permission) at the end of the fixing procedure, click on \"Next\" select \"Download ESP-IDF\" from the list and then click on \"Next\" select the most recent version 4.4 from the list (the first \"4.4\" appearing from top) and then \"Browse\" to the directory where you want to install ESP-IDF. We suggest to use the folder Documents\\esp\\esp-idf , as in figure. Then click on \"Next\" ESP-IDF is continuosly being updated, so the last 4.4 version could be different from the one shown in the following figure. click again on \"Next\", leaving unchanged the ESP-IDF Tools folder click again on \"Next\", leaving unchanged the proposed \"Full installation\" click on \"Install\" click on \"Yes\" and \"Install\" on the popup windows that will appear during the installation process. The installation may require a bit depending on your internet connection in the last window (\"Completing the ESP-IDF...\") leave only the last flag selected, as in figure, and click on \"Finish\" click on \"Yes\" on the permission popup window (if any appears) Step 2: Download GrowNode and build it launch Eclipse and in the popup window that appears select the parent folder of the ESP-IDF installation (in our case here Documents\\esp ). You can also flag \"Use this as the default...\" if you don't plan to use other workspaces click on \"Launch\" close the \"Welcome\" tab select \"Import...\" from the menu \"File\" select \"Projects from Git\" in the \"Git\" folder select \"Clone URI\" and click on \"Next >\" write https://github.com/ogghst/grownode.git into the \"URI\" field, anche click on \"Next >\" select at least the branch called \"master\", as in figure, and click on \"Next >\" indicate as \"Destination Directory\" a grownode folder located in the parent of the ESP-IDF installation (in our case here Documents\\esp ) and tick the \"Clone submodules\" flag, as in figure. Then click on \"Next >\" when some downloads end, leave the selection \"Import existing Eclipse projects\" and click on \"Next >\" select only the \"grownode\" project, as in figure, and click on \"Finish\" ...and here you go! GrowNode is imported into Eclipse. Well done! Try your first build by clicking on the hammer icon at the top left, or typing CTRL+B . In the console at the bottom you should see your project compiling and ending with the message Build complete (0 errors... . That means it was successful. Great! Step 3: Flash your board from Eclipse Before flashing you must complete some configuration steps: click on the setting gear beside \"esp32\" in the top icon bar (see point 1 in figure) select the right \"Serial Port\" from the list (most probably COM1 ) and click on \"Finish\" Now plug your board into the USB port and click on the green play icon on the top left, or type CTRL+F11 . Eclipse will start the flashing procedure (it's possible it will re-build the project before) and if everything goes well you should see the following message: Leaving... Hard resetting via RTS pin... Executing action: flash Running ninja in directory /home/your-username-here/esp/grownode/build Executing \"ninja flash\"... Did you?! Yes? Perfect! Congratulations! If the answer is no, probably you need to manually set the serial port speed and re-trigger the flashing procedure: click on the setting gear beside \"grownode\" in the top icon bar (see point 2 in the figure above) in the \"Arguments\" section add the following bold parameter exactly in the same position: idf.py -b 115200 -p /dev/your-serial-device-id flash Step 4: Monitor the serial output of your board from Eclipse To start the ESP-IDF monitor click on the icon \"Open a Terminal\" in the top icon bar (see point 1 in figure below). Check the correctness of the serial port and then click on \"Ok\". The board will restart you you will see the \"blinking\" messages. To stop the monitor, just close the \"Terminal\" window or click on the red \"Disconnect Terminal Connection\" at the top right of the terminal itself (point 2 in figure below). Great job! You are ready to play more with GrowNode ;) Appendix: Installing GrowNode into a Windows virtual machine using VirtualBox If you wish to create a new Windows virtual machine (VM) from scratch using VirtualBox just to have a try of GrowNode without affecting your system, you can still install the software environment inside the VM following the instructions of this page. How to create a Windows VM using VirtualBox is out of scope here. You can find many guides about this topic on the web. When working inside a VM you have to be aware of the following issues/requirements in order to be able to flash and properly work with your board: you must link the host serial device to a VM serial device you must plug the board via USB BEFORE starting the VM you should never unplug the board while the VM is running you will probably need to manually set the flashing baud rate to 115200 baud (as explained at the end of Step 3 above) Properly link the host and guest serial ports In VirtualBox, open the \"Serial Ports\" tab of the VM settings, shown in figure. To properly set the serial communication, you have to: flag \"Enable Serial Port\" select the \"Port Number\" from the list ( COM1 will be ok in most cases) select \"Host Device\" in \"Port Mode\" write the name of the host serial port into the \"Path/Address\" field","title":"How to get started with GrowNode on Windows 10 and Windows 11 - Easy version"},{"location":"tutorials/windows10_11_easy/#how-to-get-started-with-grownode-on-windows-10-and-windows-11-easy-version","text":"Updated on January 21, 2022","title":"How to get started with GrowNode on Windows 10 and Windows 11 - Easy version"},{"location":"tutorials/windows10_11_easy/#introduction","text":"With this step-by-step tutorial you will be able to quickly deploy the Eclipse IDE with the GrowNode development environment on your Windows 10/11 workstation. Despite the whole process is very simple, at the end of the tutorial you will have: installed the Eclipse IDE installed the ESP-IDF plugin for Eclipse installed the latest ESP-IDFv4.4 environment compiled and run your first GrowNode test board via Eclipse Notes: Only 64 bit operating systems are supported The same steps should also apply for Windows 7 64 bit, but we haven't tried yet. Let us know if you did! This procedure could be also used to create a Windows virtual machine to play with GrowNode without affecting your system. Read more details on this in the Appendix below.","title":"Introduction"},{"location":"tutorials/windows10_11_easy/#prerequisites","text":"at least 6.5 Gb free space on hard drive at least 4 Gb RAM an ESP32 board with USB cable The ESP32 board could be a ready-to-use one (like the Wemos D1 R32), or other more compact ones that need some soldering (like the ESP32-DevKitC V4 and D1 Mini ESP32).","title":"Prerequisites"},{"location":"tutorials/windows10_11_easy/#step-1-download-and-run-the-esp-idf-online-installer","text":"Download the ESP-IDF online installer from https://dl.espressif.com/dl/esp-idf/?idf=4.4 The online installer is a small program that triggers the download of the needed software. Alternatively, if you need to install the GrowNode environment on a machine without internet connection, you can also download the offline installer. Run the installer, accept the terms and conditions, and follow these steps: if suggested, click on \"Apply Fixes\" in the \"Pre-installation system check\" window (this requires Administrator rights, which you probably have, and will open another window asking for permission) at the end of the fixing procedure, click on \"Next\" select \"Download ESP-IDF\" from the list and then click on \"Next\" select the most recent version 4.4 from the list (the first \"4.4\" appearing from top) and then \"Browse\" to the directory where you want to install ESP-IDF. We suggest to use the folder Documents\\esp\\esp-idf , as in figure. Then click on \"Next\" ESP-IDF is continuosly being updated, so the last 4.4 version could be different from the one shown in the following figure. click again on \"Next\", leaving unchanged the ESP-IDF Tools folder click again on \"Next\", leaving unchanged the proposed \"Full installation\" click on \"Install\" click on \"Yes\" and \"Install\" on the popup windows that will appear during the installation process. The installation may require a bit depending on your internet connection in the last window (\"Completing the ESP-IDF...\") leave only the last flag selected, as in figure, and click on \"Finish\" click on \"Yes\" on the permission popup window (if any appears)","title":"Step 1: Download and run the ESP-IDF online installer"},{"location":"tutorials/windows10_11_easy/#step-2-download-grownode-and-build-it","text":"launch Eclipse and in the popup window that appears select the parent folder of the ESP-IDF installation (in our case here Documents\\esp ). You can also flag \"Use this as the default...\" if you don't plan to use other workspaces click on \"Launch\" close the \"Welcome\" tab select \"Import...\" from the menu \"File\" select \"Projects from Git\" in the \"Git\" folder select \"Clone URI\" and click on \"Next >\" write https://github.com/ogghst/grownode.git into the \"URI\" field, anche click on \"Next >\" select at least the branch called \"master\", as in figure, and click on \"Next >\" indicate as \"Destination Directory\" a grownode folder located in the parent of the ESP-IDF installation (in our case here Documents\\esp ) and tick the \"Clone submodules\" flag, as in figure. Then click on \"Next >\" when some downloads end, leave the selection \"Import existing Eclipse projects\" and click on \"Next >\" select only the \"grownode\" project, as in figure, and click on \"Finish\" ...and here you go! GrowNode is imported into Eclipse. Well done! Try your first build by clicking on the hammer icon at the top left, or typing CTRL+B . In the console at the bottom you should see your project compiling and ending with the message Build complete (0 errors... . That means it was successful. Great!","title":"Step 2: Download GrowNode and build it"},{"location":"tutorials/windows10_11_easy/#step-3-flash-your-board-from-eclipse","text":"Before flashing you must complete some configuration steps: click on the setting gear beside \"esp32\" in the top icon bar (see point 1 in figure) select the right \"Serial Port\" from the list (most probably COM1 ) and click on \"Finish\" Now plug your board into the USB port and click on the green play icon on the top left, or type CTRL+F11 . Eclipse will start the flashing procedure (it's possible it will re-build the project before) and if everything goes well you should see the following message: Leaving... Hard resetting via RTS pin... Executing action: flash Running ninja in directory /home/your-username-here/esp/grownode/build Executing \"ninja flash\"... Did you?! Yes? Perfect! Congratulations! If the answer is no, probably you need to manually set the serial port speed and re-trigger the flashing procedure: click on the setting gear beside \"grownode\" in the top icon bar (see point 2 in the figure above) in the \"Arguments\" section add the following bold parameter exactly in the same position: idf.py -b 115200 -p /dev/your-serial-device-id flash","title":"Step 3: Flash your board from Eclipse"},{"location":"tutorials/windows10_11_easy/#step-4-monitor-the-serial-output-of-your-board-from-eclipse","text":"To start the ESP-IDF monitor click on the icon \"Open a Terminal\" in the top icon bar (see point 1 in figure below). Check the correctness of the serial port and then click on \"Ok\". The board will restart you you will see the \"blinking\" messages. To stop the monitor, just close the \"Terminal\" window or click on the red \"Disconnect Terminal Connection\" at the top right of the terminal itself (point 2 in figure below). Great job! You are ready to play more with GrowNode ;)","title":"Step 4: Monitor the serial output of your board from Eclipse"},{"location":"tutorials/windows10_11_easy/#appendix-installing-grownode-into-a-windows-virtual-machine-using-virtualbox","text":"If you wish to create a new Windows virtual machine (VM) from scratch using VirtualBox just to have a try of GrowNode without affecting your system, you can still install the software environment inside the VM following the instructions of this page. How to create a Windows VM using VirtualBox is out of scope here. You can find many guides about this topic on the web. When working inside a VM you have to be aware of the following issues/requirements in order to be able to flash and properly work with your board: you must link the host serial device to a VM serial device you must plug the board via USB BEFORE starting the VM you should never unplug the board while the VM is running you will probably need to manually set the flashing baud rate to 115200 baud (as explained at the end of Step 3 above)","title":"Appendix: Installing GrowNode into a Windows virtual machine using VirtualBox"},{"location":"tutorials/windows10_11_easy/#properly-link-the-host-and-guest-serial-ports","text":"In VirtualBox, open the \"Serial Ports\" tab of the VM settings, shown in figure. To properly set the serial communication, you have to: flag \"Enable Serial Port\" select the \"Port Number\" from the list ( COM1 will be ok in most cases) select \"Host Device\" in \"Port Mode\" write the name of the host serial port into the \"Path/Address\" field","title":"Properly link the host and guest serial ports"}]}