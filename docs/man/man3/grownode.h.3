.TH "components/grownode/grownode.h" 3 "Wed Dec 8 2021" "GrowNode" \" -*- nroff -*-
.ad l
.nh
.SH NAME
components/grownode/grownode.h
.SH SYNOPSIS
.br
.PP
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBGN_NODE_LEAVES_MAX_SIZE\fP   64"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef \fBgn_leaf_param_validator_result_t\fP(* \fBgn_validator_t\fP) (\fBgn_leaf_param_handle_t\fP param, void **value)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBgn_node_config_handle_t\fP \fBgn_node_create\fP (\fBgn_config_handle_t\fP \fBconfig\fP, const char *name)"
.br
.RI "create a new node with specified configuration and name "
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_node_destroy\fP (\fBgn_node_config_handle_t\fP node)"
.br
.RI "removes the node from the config "
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_node_start\fP (\fBgn_node_config_handle_t\fP node)"
.br
.RI "starts the node by starting the leaves tasks "
.ti -1c
.RI "size_t \fBgn_node_get_size\fP (\fBgn_node_config_handle_t\fP \fBconfig\fP)"
.br
.RI "number of leaves into the node "
.ti -1c
.RI "\fBgn_config_handle_t\fP \fBgn_init\fP ()"
.br
.RI "performs the initialization workflow "
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_firmware_update\fP ()"
.br
.RI "send a message to the display "
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_reset\fP ()"
.br
.RI "reset the flash content and restart the board immediately "
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_reboot\fP ()"
.br
.RI "reboot the board "
.ti -1c
.RI "\fBgn_leaf_config_handle_t\fP \fBgn_leaf_create\fP (\fBgn_node_config_handle_t\fP \fBnode_config\fP, const char *name, \fBgn_leaf_config_callback\fP leaf_config, size_t task_size)"
.br
.RI "creates the leaf "
.ti -1c
.RI "\fBgn_leaf_descriptor_handle_t\fP \fBgn_leaf_get_descriptor\fP (\fBgn_leaf_config_handle_t\fP leaf_config)"
.br
.ti -1c
.RI "QueueHandle_t \fBgn_leaf_get_event_queue\fP (\fBgn_leaf_config_handle_t\fP leaf_config)"
.br
.RI "gets the leaf queue handle "
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_leaf_event_subscribe\fP (\fBgn_leaf_config_handle_t\fP leaf_config, \fBgn_event_id_t\fP event_id)"
.br
.RI "subscribe the leaf to the event id\&. "
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_leaf_event_unsubscribe\fP (\fBgn_leaf_config_handle_t\fP leaf_config, \fBgn_event_id_t\fP event_id)"
.br
.RI "unsubscribe the leaf to the event id\&. "
.ti -1c
.RI "\fBgn_leaf_param_handle_t\fP \fBgn_leaf_param_create\fP (\fBgn_leaf_config_handle_t\fP leaf_config, const char *name, const \fBgn_val_type_t\fP type, const \fBgn_val_t\fP val, \fBgn_leaf_param_access_t\fP access, \fBgn_leaf_param_storage_t\fP storage, \fBgn_validator_t\fP validator)"
.br
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_leaf_param_add\fP (const \fBgn_leaf_config_handle_t\fP leaf, const \fBgn_leaf_param_handle_t\fP new_param)"
.br
.RI "add a parameter to the leaf\&. "
.ti -1c
.RI "\fBgn_leaf_param_handle_t\fP \fBgn_leaf_param_get_param_handle\fP (const \fBgn_leaf_config_handle_t\fP leaf, const char *param_name)"
.br
.RI "returns the specific parameter associated to the leaf "
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_leaf_param_get_value\fP (const \fBgn_leaf_param_handle_t\fP param, void *val)"
.br
.RI "gets the value pointed by the parameter "
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_leaf_param_get_string\fP (const \fBgn_leaf_config_handle_t\fP leaf_config, const char *name, char *val, size_t *lenght)"
.br
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_leaf_param_set_string\fP (const \fBgn_leaf_config_handle_t\fP leaf, const char *name, char *val)"
.br
.RI "updates the parameter with new value "
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_leaf_param_init_string\fP (const \fBgn_leaf_config_handle_t\fP leaf, const char *name, char *val)"
.br
.RI "init the parameter with new value and stores in NVS flash, overwriting previous values "
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_leaf_param_get_bool\fP (const \fBgn_leaf_config_handle_t\fP leaf_config, const char *name, bool *val)"
.br
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_leaf_param_set_bool\fP (const \fBgn_leaf_config_handle_t\fP leaf, const char *name, bool val)"
.br
.RI "updates the parameter with new value "
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_leaf_param_init_bool\fP (const \fBgn_leaf_config_handle_t\fP leaf, const char *name, bool val)"
.br
.RI "init the parameter with new value and stores in NVS flash, overwriting previous values "
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_leaf_param_get_double\fP (const \fBgn_leaf_config_handle_t\fP leaf_config, const char *name, double *val)"
.br
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_leaf_param_set_double\fP (const \fBgn_leaf_config_handle_t\fP leaf, const char *name, double val)"
.br
.RI "updates the parameter with new value "
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_leaf_param_init_double\fP (const \fBgn_leaf_config_handle_t\fP leaf, const char *name, double val)"
.br
.RI "init the parameter with new value and stores in NVS flash, overwriting previous values "
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_log\fP (char *log_tag, \fBgn_log_level_t\fP level, char *message,\&.\&.\&.)"
.br
.RI "write ESP log, send log in the event queue and publish in network "
.ti -1c
.RI "\fBgn_config_status_t\fP \fBgn_get_config_status\fP (\fBgn_config_handle_t\fP \fBconfig\fP)"
.br
.RI "retrieves the configuration status "
.ti -1c
.RI "esp_event_loop_handle_t \fBgn_get_config_event_loop\fP (\fBgn_config_handle_t\fP \fBconfig\fP)"
.br
.RI "retrieves the event loop starting from the config handle "
.ti -1c
.RI "esp_event_loop_handle_t \fBgn_leaf_get_config_event_loop\fP (\fBgn_config_handle_t\fP \fBconfig\fP)"
.br
.RI "retrieves the event loop starting from the leaf config handle "
.ti -1c
.RI "char * \fBgn_get_node_config_name\fP (\fBgn_node_config_handle_t\fP \fBnode_config\fP)"
.br
.RI "gets the name from the node config "
.ti -1c
.RI "char * \fBgn_leaf_get_config_name\fP (\fBgn_leaf_config_handle_t\fP leaf_config)"
.br
.RI "gets the name of the leaf referenced by the handle "
.ti -1c
.RI "\fBgn_leaf_config_handle_t\fP \fBgn_leaf_get_config_handle\fP (\fBgn_node_config_handle_t\fP node, const char *name)"
.br
.ti -1c
.RI "\fBgn_node_config_handle_t\fP \fBgn_leaf_get_node_config\fP (\fBgn_leaf_config_handle_t\fP leaf_config)"
.br
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_send_leaf_param_change_message\fP (const char *leaf_name, const char *param_name, const void *message, size_t message_len)"
.br
.RI "send a request to change a parameter name "
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_leaf_param_send_bool\fP (const \fBgn_leaf_config_handle_t\fP leaf_config, const char *name, bool val)"
.br
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_leaf_param_send_double\fP (const \fBgn_leaf_config_handle_t\fP leaf_config, const char *name, double val)"
.br
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_leaf_param_send_string\fP (const \fBgn_leaf_config_handle_t\fP leaf_config, const char *name, char *val)"
.br
.ti -1c
.RI "\fBgn_display_container_t\fP \fBgn_display_setup_leaf_display\fP (\fBgn_leaf_config_handle_t\fP leaf_config)"
.br
.RI "prepare a container where to draw the display components of the leaf "
.ti -1c
.RI "BaseType_t \fBgn_display_leaf_refresh_start\fP ()"
.br
.RI "start of code guard to ensure the block will be executed outside display refresh task "
.ti -1c
.RI "BaseType_t \fBgn_display_leaf_refresh_end\fP ()"
.br
.RI "end of code guard to ensure the block will be executed outside display refresh task "
.ti -1c
.RI "\fBgn_server_status_t\fP \fBgn_mqtt_get_status\fP ()"
.br
.RI "returns the status of the server "
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_storage_set\fP (const char *key, const void *value, size_t required_size)"
.br
.RI "stores the key into the NVS flash "
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_storage_get\fP (const char *key, void **value)"
.br
.RI "retrieves the key from the NVS flash "
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define GN_NODE_LEAVES_MAX_SIZE   64"

.SH "Typedef Documentation"
.PP 
.SS "typedef \fBgn_leaf_param_validator_result_t\fP(* gn_validator_t) (\fBgn_leaf_param_handle_t\fP param, void **value)"

.SH "Function Documentation"
.PP 
.SS "BaseType_t gn_display_leaf_refresh_end ()"

.PP
end of code guard to ensure the block will be executed outside display refresh task this is implemented with xSemaphoreGive
.PP
\fBReturns\fP
.RS 4
result of the xSemaphoreTake function 
.RE
.PP

.SS "BaseType_t gn_display_leaf_refresh_start ()"

.PP
start of code guard to ensure the block will be executed outside display refresh task this is implemented with xSemaphoreTake
.PP
\fBReturns\fP
.RS 4
result of the xSemaphoreTake function 
.RE
.PP

.SS "\fBgn_display_container_t\fP gn_display_setup_leaf_display (\fBgn_leaf_config_handle_t\fP leaf_config)"

.PP
prepare a container where to draw the display components of the leaf this has to be called into the display refresh task 
.PP
\fBSee also\fP
.RS 4
\fBgn_display_leaf_refresh_start()\fP
.RE
.PP
\fBReturns\fP
.RS 4
a pointer to lv_obj_t (to be casted) 
.RE
.PP

.SS "\fBgn_err_t\fP gn_firmware_update ()"

.PP
send a message to the display implemented by sending an internal GN_DISPLAY_LOG_EVENT event NOTE: data will be truncated depending on display size
.PP
\fBParameters\fP
.RS 4
\fImessage\fP the message to send (null terminated)
.RE
.PP
\fBReturns\fP
.RS 4
GN_RET_OK if event is dispatched 
.PP
GN_RET_ERR if the event dispatch encounters a problem 
.PP
GN_RET_ERR_INVALID_ARG if message is NULL or zero length
.RE
.PP
starts the OTA firmware upgrade
.PP
it starts the OTA tasks so it returns immediately
.PP
\fBReturns\fP
.RS 4
GN_RET_OK 
.RE
.PP

.SS "esp_event_loop_handle_t gn_get_config_event_loop (\fBgn_config_handle_t\fP config)"

.PP
retrieves the event loop starting from the config handle 
.PP
\fBParameters\fP
.RS 4
\fIconfig\fP the config handle
.RE
.PP
\fBReturns\fP
.RS 4
the event loop 
.PP
NULL if config not valid 
.RE
.PP

.SS "\fBgn_config_status_t\fP gn_get_config_status (\fBgn_config_handle_t\fP config)"

.PP
retrieves the configuration status 
.PP
\fBParameters\fP
.RS 4
\fIconfig\fP the configuration handle to check
.RE
.PP
\fBReturns\fP
.RS 4
GN_CONFIG_STATUS_ERROR if config is NULL 
.PP
the configuration status 
.RE
.PP

.SS "char* gn_get_node_config_name (\fBgn_node_config_handle_t\fP node_config)"

.PP
gets the name from the node config 
.PP
\fBParameters\fP
.RS 4
\fInode_config\fP the node config to search for
.RE
.PP
\fBReturns\fP
.RS 4
the node config name (null terminated) 
.PP
NULL if node config not found 
.RE
.PP

.SS "\fBgn_config_handle_t\fP gn_init ()"

.PP
performs the initialization workflow 
.IP "\(bu" 2
creates the configuration handle
.IP "\(bu" 2
initializes hardware (flash, storage)
.IP "\(bu" 2
initializes event loop and handlers
.IP "\(bu" 2
initializes display if configured
.IP "\(bu" 2
initializes network if configured (starting provisioning is not set)
.IP "\(bu" 2
initializes server connection
.PP
.PP
this is a process that will continue even after the function returns, eg for network/server connection
.PP
when everything is OK it sets the status of the config handle to GN_CONFIG_STATUS_ERROR
.PP
NOTE: if called several times, it returns always the same handle
.PP
\fBReturns\fP
.RS 4
an handle to the config data structure 
.RE
.PP

.SS "\fBgn_leaf_config_handle_t\fP gn_leaf_create (\fBgn_node_config_handle_t\fP node_config, const char * name, \fBgn_leaf_config_callback\fP leaf_config, size_t task_size)"

.PP
creates the leaf initializes the leaf structure\&. the returned handle is not active and need to be started by the \fBgn_node_start()\fP function 
.PP
\fBSee also\fP
.RS 4
\fBgn_node_start()\fP 
.RE
.PP
\fBParameters\fP
.RS 4
\fInode_config\fP the configuration handle to create the leaf to 
.br
\fIname\fP the name of the leaf to be created 
.br
\fItask\fP callback function of the leaf task 
.br
\fItask_size\fP the size of the task to be memory allocated
.RE
.PP
\fBReturns\fP
.RS 4
an handle to the leaf config 
.PP
NULL if the handle cannot be created 
.RE
.PP

.SS "\fBgn_err_t\fP gn_leaf_event_subscribe (\fBgn_leaf_config_handle_t\fP leaf_config, \fBgn_event_id_t\fP event_id)"

.PP
subscribe the leaf to the event id\&. 
.PP
\fBReturns\fP
.RS 4
GN_RET_OK if successful 
.RE
.PP

.SS "\fBgn_err_t\fP gn_leaf_event_unsubscribe (\fBgn_leaf_config_handle_t\fP leaf_config, \fBgn_event_id_t\fP event_id)"

.PP
unsubscribe the leaf to the event id\&. 
.PP
\fBReturns\fP
.RS 4
GN_RET_OK if successful 
.RE
.PP

.SS "esp_event_loop_handle_t gn_leaf_get_config_event_loop (\fBgn_leaf_config_handle_t\fP leaf_config)"

.PP
retrieves the event loop starting from the leaf config handle 
.PP
\fBParameters\fP
.RS 4
\fIleaf_config\fP the leaf config handle
.RE
.PP
\fBReturns\fP
.RS 4
the event loop 
.PP
NULL if leaf config not valid 
.RE
.PP

.SS "\fBgn_leaf_config_handle_t\fP gn_leaf_get_config_handle (\fBgn_node_config_handle_t\fP node, const char * name)"

.SS "char* gn_leaf_get_config_name (\fBgn_leaf_config_handle_t\fP leaf_config)"

.PP
gets the name of the leaf referenced by the handle 
.PP
\fBParameters\fP
.RS 4
\fIleaf_config\fP the handle to be queried
.RE
.PP
\fBReturns\fP
.RS 4
a pointer to the leaf name\&. 
.PP
NULL if the handle is not valid 
.RE
.PP

.SS "\fBgn_leaf_descriptor_handle_t\fP gn_leaf_get_descriptor (\fBgn_leaf_config_handle_t\fP leaf_config)"
returns the descriptor handle for the corresponding leaf 
.SS "QueueHandle_t gn_leaf_get_event_queue (\fBgn_leaf_config_handle_t\fP leaf_config)"

.PP
gets the leaf queue handle 
.PP
\fBParameters\fP
.RS 4
\fIleaf_config\fP the leaf to be queried
.RE
.PP
\fBReturns\fP
.RS 4
the queue handle 
.PP
NULL if leaf not found 
.RE
.PP

.SS "\fBgn_node_config_handle_t\fP gn_leaf_get_node_config (\fBgn_leaf_config_handle_t\fP leaf_config)"

.SS "\fBgn_err_t\fP gn_leaf_param_add (const \fBgn_leaf_config_handle_t\fP leaf, const \fBgn_leaf_param_handle_t\fP param)"

.PP
add a parameter to the leaf\&. the parameter will then listen to server changes
.PP
\fBParameters\fP
.RS 4
\fIleaf\fP the leaf handle 
.br
\fInew_param\fP the param to add to the leaf\&. the leaf will point at it upon method return
.RE
.PP
\fBReturns\fP
.RS 4
GN_RET_ERR_INVALID_ARG in case of parameter errors 
.PP
GN_RET_OK upon success 
.RE
.PP

.SS "\fBgn_leaf_param_handle_t\fP gn_leaf_param_create (\fBgn_leaf_config_handle_t\fP leaf_config, const char * name, const \fBgn_val_type_t\fP type, \fBgn_val_t\fP val, \fBgn_leaf_param_access_t\fP access, \fBgn_leaf_param_storage_t\fP storage, \fBgn_validator_t\fP validator)"

.PP
.nf
@brief  creates a parameter on the leaf

NOTE: if parameter is stored, the value is overridden

.fi
.PP
 
.PP
\fBParameters\fP
.RS 4
\fIleaf_config\fP the leaf to be queried 
.br
\fIname\fP the name of the parameter (null terminated char array) 
.br
\fItype\fP the type of parameter 
.br
\fIval\fP the value of parameter 
.br
\fIaccess\fP access type of parameter 
.br
\fIstorage\fP storage type of parameter
.RE
.PP
\fBReturns\fP
.RS 4
the new parameter handle 
.PP
NULL in case of errors 
.RE
.PP

.SS "\fBgn_err_t\fP gn_leaf_param_get_bool (const \fBgn_leaf_config_handle_t\fP leaf_config, const char * name, bool * val)"

.SS "\fBgn_err_t\fP gn_leaf_param_get_double (const \fBgn_leaf_config_handle_t\fP leaf_config, const char * name, double * val)"

.SS "\fBgn_leaf_param_handle_t\fP gn_leaf_param_get_param_handle (const \fBgn_leaf_config_handle_t\fP leaf_config, const char * param_name)"

.PP
returns the specific parameter associated to the leaf 
.PP
\fBParameters\fP
.RS 4
\fIleaf_config\fP the leaf handle to search within 
.br
\fIparam_name\fP the name of the parameter (null terminated)
.RE
.PP
\fBReturns\fP
.RS 4
NULL if leaf_config or the parameter is not found 
.PP
the found parameter handle 
.RE
.PP

.SS "\fBgn_err_t\fP gn_leaf_param_get_string (const \fBgn_leaf_config_handle_t\fP leaf_config, const char * name, char * val, size_t * lenght)"

.SS "\fBgn_err_t\fP gn_leaf_param_get_value (const \fBgn_leaf_param_handle_t\fP param, void * val)"

.PP
gets the value pointed by the parameter 
.PP
\fBParameters\fP
.RS 4
\fIparam\fP the parameter handle to look at @val the value returned 
.RE
.PP

.SS "\fBgn_err_t\fP gn_leaf_param_init_bool (const \fBgn_leaf_config_handle_t\fP leaf_config, const char * name, bool val)"

.PP
init the parameter with new value and stores in NVS flash, overwriting previous values the leaf must be not initialized to have an effect\&. the parameter value will be copied to the corresponding handle\&.
.PP
\fBParameters\fP
.RS 4
\fIleaf_config\fP the leaf handle to be queried 
.br
\fIname\fP the name of the parameter (null terminated) 
.br
\fIval\fP the value to set
.RE
.PP
\fBReturns\fP
.RS 4
GN_RET_OK if the parameter is set 
.PP
GN_RET_ERR_INVALID_ARG in case of input errors 
.RE
.PP

.SS "\fBgn_err_t\fP gn_leaf_param_init_double (const \fBgn_leaf_config_handle_t\fP leaf_config, const char * name, double val)"

.PP
init the parameter with new value and stores in NVS flash, overwriting previous values the leaf must be not initialized to have an effect\&. the parameter value will be copied to the corresponding handle\&.
.PP
\fBParameters\fP
.RS 4
\fIleaf_config\fP the leaf handle to be queried 
.br
\fIname\fP the name of the parameter (null terminated) 
.br
\fIval\fP the value to set
.RE
.PP
\fBReturns\fP
.RS 4
GN_RET_OK if the parameter is set 
.PP
GN_RET_ERR_INVALID_ARG in case of input errors 
.RE
.PP

.SS "\fBgn_err_t\fP gn_leaf_param_init_string (const \fBgn_leaf_config_handle_t\fP leaf_config, const char * name, char * val)"

.PP
init the parameter with new value and stores in NVS flash, overwriting previous values the leaf must be not initialized to have an effect\&. the parameter value will be copied to the corresponding handle\&.
.PP
\fBParameters\fP
.RS 4
\fIleaf_config\fP the leaf handle to be queried 
.br
\fIname\fP the name of the parameter (null terminated) 
.br
\fIval\fP the value to set
.RE
.PP
\fBReturns\fP
.RS 4
GN_RET_OK if the parameter is set 
.PP
GN_RET_ERR_INVALID_ARG in case of input errors 
.RE
.PP

.SS "\fBgn_err_t\fP gn_leaf_param_send_bool (const \fBgn_leaf_config_handle_t\fP leaf_config, const char * name, bool val)"

.SS "\fBgn_err_t\fP gn_leaf_param_send_double (const \fBgn_leaf_config_handle_t\fP leaf_config, const char * name, double val)"

.SS "\fBgn_err_t\fP gn_leaf_param_send_string (const \fBgn_leaf_config_handle_t\fP leaf_config, const char * name, char * val)"

.SS "\fBgn_err_t\fP gn_leaf_param_set_bool (const \fBgn_leaf_config_handle_t\fP leaf_config, const char * name, bool val)"

.PP
updates the parameter with new value the parameter value will be copied to the corresponding handle\&. after the change the parameter change will be propagated to the event system through a GN_LEAF_PARAM_CHANGED_EVENT and to the server\&.
.PP
\fBParameters\fP
.RS 4
\fIleaf_config\fP the leaf handle to be queried 
.br
\fIname\fP the name of the parameter (null terminated) 
.br
\fIval\fP the value to set (null terminated)
.RE
.PP
\fBReturns\fP
.RS 4
GN_RET_OK if the parameter is set 
.PP
GN_RET_ERR_INVALID_ARG in case of input errors 
.RE
.PP

.SS "\fBgn_err_t\fP gn_leaf_param_set_double (const \fBgn_leaf_config_handle_t\fP leaf_config, const char * name, double val)"

.PP
updates the parameter with new value the leaf must be already initialized to have an effect\&. the parameter value will be copied to the corresponding handle\&. after the change the parameter change will be propagated to the event system through a GN_LEAF_PARAM_CHANGED_EVENT and to the server\&.
.PP
\fBParameters\fP
.RS 4
\fIleaf_config\fP the leaf handle to be queried 
.br
\fIname\fP the name of the parameter (null terminated) 
.br
\fIval\fP the value to set
.RE
.PP
\fBReturns\fP
.RS 4
GN_RET_OK if the parameter is set 
.PP
GN_RET_ERR_INVALID_ARG in case of input errors 
.RE
.PP

.SS "\fBgn_err_t\fP gn_leaf_param_set_string (const \fBgn_leaf_config_handle_t\fP leaf_config, const char * name, char * val)"

.PP
updates the parameter with new value the parameter value will be copied to the corresponding handle\&. after the change the parameter change will be propagated to the event system through a GN_LEAF_PARAM_CHANGED_EVENT and to the server\&.
.PP
\fBParameters\fP
.RS 4
\fIleaf_config\fP the leaf handle to be queried 
.br
\fIname\fP the name of the parameter (null terminated) 
.br
\fIval\fP the value to set (null terminated)
.RE
.PP
\fBReturns\fP
.RS 4
GN_RET_OK if the parameter is set 
.PP
GN_RET_ERR_INVALID_ARG in case of input errors 
.RE
.PP

.SS "\fBgn_err_t\fP gn_log (char * log_tag, \fBgn_log_level_t\fP level, char * message,  \&.\&.\&.)"

.PP
write ESP log, send log in the event queue and publish in network 
.PP
\fBParameters\fP
.RS 4
\fIlog_tag\fP log level, will be the TAG in ESP logging framework 
.br
\fIlevel\fP grownode log level 
.br
\fImessage\fP the null terminated message to log 
.PP
.nf
@return GN_RET_OK if event is dispatched
@return GN_RET_ERR if the event dispatch encounters a problem
@return GN_RET_ERR_INVALID_ARG if message is NULL or zero length

.fi
.PP
 
.RE
.PP

.SS "\fBgn_server_status_t\fP gn_mqtt_get_status ()"

.PP
returns the status of the server 
.PP
\fBReturns\fP
.RS 4
the current status 
.RE
.PP

.SS "\fBgn_node_config_handle_t\fP gn_node_create (\fBgn_config_handle_t\fP config, const char * name)"

.PP
create a new node with specified configuration and name 
.PP
\fBParameters\fP
.RS 4
\fIconfig\fP the config handle to use 
.br
\fIname\fP name of the node\&. MUST BE null terminated
.RE
.PP
\fBReturns\fP
.RS 4
the node handle created\&. 
.RE
.PP

.SS "\fBgn_err_t\fP gn_node_destroy (\fBgn_node_config_handle_t\fP node)"

.PP
removes the node from the config 
.PP
\fBParameters\fP
.RS 4
\fInode\fP the node to be removed
.RE
.PP
\fBReturns\fP
.RS 4
GN_RET_OK if operation had succeded 
.RE
.PP

.SS "size_t gn_node_get_size (\fBgn_node_config_handle_t\fP node_config)"

.PP
number of leaves into the node 
.PP
\fBParameters\fP
.RS 4
\fInode_config\fP the node to be inspected
.RE
.PP
\fBReturns\fP
.RS 4
number of leaves into the node, -1 in case node_config is NULL 
.RE
.PP

.SS "\fBgn_err_t\fP gn_node_start (\fBgn_node_config_handle_t\fP node)"

.PP
starts the node by starting the leaves tasks At the end of the process, it sets the node status to GN_CONFIG_STATUS_STARTED and sends a GN_NODE_STARTED_EVENT event
.PP
\fBParameters\fP
.RS 4
\fInode\fP the node to be started
.RE
.PP
\fBReturns\fP
.RS 4
GN_RET_OK if operation had succeded, GN_RET_ERR_NODE_NOT_STARTED in case of issues 
.RE
.PP

.SS "\fBgn_err_t\fP gn_reboot ()"

.PP
reboot the board 
.PP
\fBReturns\fP
.RS 4
GN_RET_OK 
.RE
.PP

.SS "\fBgn_err_t\fP gn_reset ()"

.PP
reset the flash content and restart the board immediately 
.PP
\fBReturns\fP
.RS 4
GN_RET_OK 
.RE
.PP

.SS "\fBgn_err_t\fP gn_send_leaf_param_change_message (const char * leaf_name, const char * param_name, const void * message, size_t message_len)"

.PP
send a request to change a parameter name It sends a GN_LEAF_PARAM_CHANGE_REQUEST_EVENT to the leaf parameter, if the parameter is modifiable
.PP
\fBParameters\fP
.RS 4
\fIleaf_name\fP the leaf name (null terminated) to send the request to 
.br
\fIparam_name\fP the parameter name to change (null terminated) 
.br
\fImessage\fP a pointer to the payload 
.br
\fImessage_len\fP size of the payload
.RE
.PP
\fBReturns\fP
.RS 4
GN_RET_ERR_LEAF_NOT_FOUND if the leaf is not found 
.PP
GN_RET_ERR_INVALID_ARG in case of input parameter error 
.PP
GN_RET_ERR_LEAF_PARAM_ACCESS_VIOLATION in case the parameter access is not write enable 
.RE
.PP

.SS "\fBgn_err_t\fP gn_storage_get (const char * key, void ** value)"

.PP
retrieves the key from the NVS flash internally, this is implemented by retrieving raw bytes to the flash storage
.PP
\fBParameters\fP
.RS 4
\fIkey\fP name (null terminated) 
.br
\fIvalue\fP pointer where the pointer of the data acquired will be stored
.RE
.PP
\fBReturns\fP
.RS 4
GN_RET_ERR_INVALID_ARG if input params are not valid 
.PP
GN_RET_OK if key is stored successfully 
.RE
.PP

.SS "\fBgn_err_t\fP gn_storage_set (const char * key, const void * value, size_t required_size)"

.PP
stores the key into the NVS flash internally, this is implemented by copying raw bytes to the flash storage
.PP
\fBParameters\fP
.RS 4
\fIkey\fP name (null terminated) 
.br
\fIvalue\fP pointer to data 
.br
\fIrequired_size\fP bytes to write
.RE
.PP
\fBReturns\fP
.RS 4
GN_RET_ERR_INVALID_ARG if input params are not valid 
.PP
GN_RET_OK if key is stored successfully 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for GrowNode from the source code\&.
