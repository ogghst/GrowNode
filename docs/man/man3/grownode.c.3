.TH "components/grownode/grownode.c" 3 "Sat Jan 29 2022" "GrowNode" \" -*- nroff -*-
.ad l
.nh
.SH NAME
components/grownode/grownode.c
.SH SYNOPSIS
.br
.PP
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBTAG\fP   'grownode'"
.br
.ti -1c
.RI "#define \fBTAG_EVENT\fP   'gn_event'"
.br
.ti -1c
.RI "#define \fBTAG_NVS\fP   'gn_nvs'"
.br
.ti -1c
.RI "#define \fBTIMER_DIVIDER\fP   (16)"
.br
.ti -1c
.RI "#define \fBTIMER_SCALE\fP   (TIMER_BASE_CLK / \fBTIMER_DIVIDER\fP)"
.br
.ti -1c
.RI "#define \fBSTORAGE_NAMESPACE\fP   'grownode'"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBESP_EVENT_DEFINE_BASE\fP (\fBGN_BASE_EVENT\fP)"
.br
.ti -1c
.RI "\fBESP_EVENT_DEFINE_BASE\fP (\fBGN_LEAF_EVENT\fP)"
.br
.ti -1c
.RI "\fBgn_err_t\fP \fB_gn_leaf_start\fP (\fBgn_leaf_config_handle_intl_t\fP leaf_config)"
.br
.RI "start the leaf by starting a new task and subscribing to network messages "
.ti -1c
.RI "\fBgn_err_t\fP \fB_gn_init_flash\fP (\fBgn_config_handle_t\fP conf)"
.br
.ti -1c
.RI "esp_err_t \fB_gn_init_spiffs\fP (\fBgn_config_handle_intl_t\fP conf)"
.br
.ti -1c
.RI "static bool IRAM_ATTR \fB_gn_timer_callback_isr\fP (void *args)"
.br
.ti -1c
.RI "void \fB_gn_keepalive_start\fP ()"
.br
.ti -1c
.RI "void \fB_gn_keepalive_stop\fP ()"
.br
.ti -1c
.RI "\fBgn_leaf_config_handle_intl_t\fP \fB_gn_leaf_get_by_name\fP (char *leaf_name)"
.br
.ti -1c
.RI "\fBgn_err_t\fP \fB_gn_send_event_to_leaf\fP (\fBgn_leaf_config_handle_intl_t\fP leaf_config, \fBgn_leaf_parameter_event_handle_t\fP evt)"
.br
.RI "send event to leaf using xQueueSend\&. the data will be null terminated\&. "
.ti -1c
.RI "void \fB_gn_evt_handler\fP (void *handler_args, esp_event_base_t base, int32_t id, void *event_data)"
.br
.ti -1c
.RI "esp_err_t \fB_gn_evt_handlers_register\fP (\fBgn_config_handle_intl_t\fP conf)"
.br
.ti -1c
.RI "esp_err_t \fB_gn_init_keepalive_timer\fP (\fBgn_config_handle_intl_t\fP conf)"
.br
.ti -1c
.RI "\fBgn_config_handle_intl_t\fP \fB_gn_config_create\fP (\fBgn_config_init_param_t\fP *config_init)"
.br
.RI "initialize config "
.ti -1c
.RI "esp_err_t \fB_gn_init_event_loop\fP (\fBgn_config_handle_intl_t\fP config)"
.br
.ti -1c
.RI "\fBgn_node_config_handle_intl_t\fP \fB_gn_node_config_create\fP ()"
.br
.ti -1c
.RI "\fBgn_node_status_t\fP \fBgn_get_status\fP (\fBgn_config_handle_t\fP config)"
.br
.RI "retrieves the configuration status "
.ti -1c
.RI "const char * \fBgn_get_status_description\fP (\fBgn_config_handle_t\fP config)"
.br
.RI "retrieves the configuration status description "
.ti -1c
.RI "esp_event_loop_handle_t \fBgn_get_event_loop\fP (\fBgn_config_handle_t\fP config)"
.br
.RI "retrieves the event loop starting from the config handle "
.ti -1c
.RI "esp_event_loop_handle_t \fBgn_leaf_get_event_loop\fP (\fBgn_leaf_handle_t\fP leaf_config)"
.br
.RI "retrieves the event loop starting from the leaf config handle "
.ti -1c
.RI "\fBgn_node_handle_t\fP \fBgn_node_create\fP (\fBgn_config_handle_t\fP config, const char *name)"
.br
.RI "create a new node with specified configuration and name "
.ti -1c
.RI "size_t \fBgn_node_get_size\fP (\fBgn_node_handle_t\fP node_config)"
.br
.RI "number of leaves into the node "
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_node_destroy\fP (\fBgn_node_handle_t\fP node)"
.br
.RI "removes the node from the config "
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_node_start\fP (\fBgn_node_handle_t\fP node)"
.br
.RI "starts the node by starting the leaves tasks "
.ti -1c
.RI "\fBgn_leaf_config_handle_intl_t\fP \fB_gn_leaf_config_create\fP ()"
.br
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_node_get_name\fP (\fBgn_node_handle_t\fP node_config, char *name)"
.br
.RI "gets the name of the node referenced by the handle "
.ti -1c
.RI "\fBgn_leaf_handle_t\fP \fBgn_leaf_create\fP (\fBgn_node_handle_t\fP node_config, const char *name, \fBgn_leaf_config_callback\fP callback, size_t task_size)"
.br
.RI "creates the leaf "
.ti -1c
.RI "\fBgn_leaf_descriptor_handle_t\fP \fBgn_leaf_get_descriptor\fP (\fBgn_leaf_handle_t\fP leaf_config)"
.br
.ti -1c
.RI "\fBgn_err_t\fP \fB_gn_leaf_destroy\fP (\fBgn_leaf_handle_t\fP leaf_config)"
.br
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_leaf_get_name\fP (\fBgn_leaf_handle_t\fP leaf_config, char *name)"
.br
.RI "gets the name of the leaf referenced by the handle "
.ti -1c
.RI "\fBgn_leaf_handle_t\fP \fBgn_leaf_get_config_handle\fP (\fBgn_node_handle_t\fP node, const char *name)"
.br
.ti -1c
.RI "\fBgn_node_handle_t\fP \fBgn_leaf_get_node\fP (\fBgn_leaf_handle_t\fP leaf_config)"
.br
.ti -1c
.RI "QueueHandle_t \fBgn_leaf_get_event_queue\fP (\fBgn_leaf_handle_t\fP leaf_config)"
.br
.RI "gets the leaf queue handle "
.ti -1c
.RI "void \fB_gn_leaf_evt_handler\fP (void *handler_args, esp_event_base_t base, int32_t id, void *event_data)"
.br
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_leaf_event_subscribe\fP (\fBgn_leaf_handle_t\fP leaf_config, \fBgn_event_id_t\fP event_id)"
.br
.RI "subscribe the leaf to the event id\&. "
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_leaf_event_unsubscribe\fP (\fBgn_leaf_handle_t\fP leaf_config, \fBgn_event_id_t\fP event_id)"
.br
.RI "unsubscribe the leaf to the event id\&. "
.ti -1c
.RI "\fBgn_leaf_param_handle_t\fP \fBgn_leaf_param_create\fP (\fBgn_leaf_handle_t\fP leaf_config, const char *name, const \fBgn_val_type_t\fP type, \fBgn_val_t\fP val, \fBgn_leaf_param_access_type_t\fP access, \fBgn_leaf_param_storage_t\fP storage, \fBgn_validator_callback_t\fP validator)"
.br
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_leaf_param_init_string\fP (const \fBgn_leaf_handle_t\fP leaf_config, const char *name, const char *val)"
.br
.RI "init the parameter with new value and stores in NVS flash, overwriting previous values "
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_leaf_param_set_string\fP (const \fBgn_leaf_handle_t\fP leaf_config, const char *name, char *val)"
.br
.RI "updates the parameter with new value "
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_leaf_param_get_string\fP (const \fBgn_leaf_handle_t\fP leaf_config, const char *name, char *val, size_t max_lenght)"
.br
.RI "gets the parameter value "
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_leaf_param_init_bool\fP (const \fBgn_leaf_handle_t\fP leaf_config, const char *name, bool val)"
.br
.RI "init the parameter with new value and stores in NVS flash, overwriting previous values "
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_leaf_param_set_bool\fP (const \fBgn_leaf_handle_t\fP leaf_config, const char *name, bool val)"
.br
.RI "updates the parameter with new value "
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_leaf_param_set_value\fP (const \fBgn_leaf_param_handle_t\fP param_handle, const void *value)"
.br
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_leaf_param_get_bool\fP (const \fBgn_leaf_handle_t\fP leaf_config, const char *name, bool *val)"
.br
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_leaf_param_init_double\fP (const \fBgn_leaf_handle_t\fP leaf_config, const char *name, double val)"
.br
.RI "init the parameter with new value and stores in NVS flash, overwriting previous values "
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_leaf_param_set_double\fP (const \fBgn_leaf_handle_t\fP leaf_config, const char *name, double val)"
.br
.RI "updates the parameter with new value "
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_leaf_param_get_value\fP (const \fBgn_leaf_param_handle_t\fP param, void *val)"
.br
.RI "gets the value pointed by the parameter "
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_leaf_param_get_double\fP (const \fBgn_leaf_handle_t\fP leaf_config, const char *name, double *val)"
.br
.ti -1c
.RI "\fBgn_err_t\fP \fB_gn_leaf_parameter_update\fP (const \fBgn_leaf_handle_t\fP leaf_config, const char *param, const void *data, const int data_len)"
.br
.ti -1c
.RI "\fBgn_err_t\fP \fB_gn_leaf_param_destroy\fP (\fBgn_leaf_param_handle_t\fP param)"
.br
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_leaf_param_add_to_leaf\fP (const \fBgn_leaf_handle_t\fP leaf, const \fBgn_leaf_param_handle_t\fP param)"
.br
.RI "add a parameter to the leaf\&. "
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_send_node_leaf_param_status\fP (const \fBgn_node_handle_t\fP _node_config)"
.br
.RI "send parameter status per each parameter "
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_send_leaf_param_change_message\fP (const char *leaf_name, const char *param_name, const void *message, size_t message_len)"
.br
.RI "send a request to change a parameter name "
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_leaf_param_update_bool\fP (const \fBgn_leaf_handle_t\fP leaf_config, const char *name, bool val)"
.br
.RI "generate a request to update the parameter to the leaf\&. "
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_leaf_param_update_double\fP (const \fBgn_leaf_handle_t\fP leaf_config, const char *name, double val)"
.br
.RI "generate a request to update the parameter to the leaf\&. "
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_leaf_param_update_string\fP (const \fBgn_leaf_handle_t\fP leaf_config, const char *name, char *val)"
.br
.RI "generate a request to update the parameter to the leaf\&. "
.ti -1c
.RI "\fBgn_leaf_param_handle_t\fP \fBgn_leaf_get_params\fP (\fBgn_leaf_handle_t\fP leaf_config)"
.br
.RI "returns the first parameter associated to the leaf "
.ti -1c
.RI "\fBgn_leaf_param_handle_t\fP \fBgn_leaf_param_get_param_handle\fP (const \fBgn_leaf_handle_t\fP leaf_config, const char *param_name)"
.br
.RI "returns the specific parameter associated to the leaf "
.ti -1c
.RI "void * \fB_gn_leaf_context_add_to_leaf\fP (const \fBgn_leaf_handle_t\fP leaf, char *key, void *value)"
.br
.ti -1c
.RI "void * \fB_gn_leaf_context_remove_to_leaf\fP (const \fBgn_leaf_handle_t\fP leaf, char *key)"
.br
.ti -1c
.RI "void * \fB_gn_leaf_context_get_key_to_leaf\fP (const \fBgn_leaf_handle_t\fP leaf, char *key)"
.br
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_firmware_update\fP ()"
.br
.RI "send a message to the display "
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_reset\fP ()"
.br
.RI "reset the flash content and restart the board immediately "
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_log\fP (char *log_tag, \fBgn_log_level_t\fP level, const char *message,\&.\&.\&.)"
.br
.RI "write ESP log, send log in the event queue and publish in network "
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_reboot\fP ()"
.br
.RI "reboot the board "
.ti -1c
.RI "\fBgn_config_handle_t\fP \fBgn_init\fP (\fBgn_config_init_param_t\fP *config_init)"
.br
.RI "performs the initialization workflow "
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_storage_set\fP (const char *key, const void *value, size_t required_size)"
.br
.RI "stores the key into the NVS flash "
.ti -1c
.RI "\fBgn_err_t\fP \fBgn_storage_get\fP (const char *key, void **value)"
.br
.RI "retrieves the key from the NVS flash "
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "esp_event_loop_handle_t \fBgn_event_loop\fP = NULL"
.br
.ti -1c
.RI "\fBgn_config_handle_intl_t\fP \fB_gn_default_conf\fP = NULL"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define STORAGE_NAMESPACE   'grownode'"

.SS "#define TAG   'grownode'"

.SS "#define TAG_EVENT   'gn_event'"

.SS "#define TAG_NVS   'gn_nvs'"

.SS "#define TIMER_DIVIDER   (16)"

.SS "#define TIMER_SCALE   (TIMER_BASE_CLK / \fBTIMER_DIVIDER\fP)"

.SH "Function Documentation"
.PP 
.SS "\fBgn_config_handle_intl_t\fP _gn_config_create (\fBgn_config_init_param_t\fP * config_init)"

.PP
initialize config 
.PP
\fBReturns\fP
.RS 4
the configuration with its state (GN_CONFIG_STATUS_NOT_INITIALIZED as default) 
.RE
.PP

.SS "void _gn_evt_handler (void * handler_args, esp_event_base_t base, int32_t id, void * event_data)"

.SS "esp_err_t _gn_evt_handlers_register (\fBgn_config_handle_intl_t\fP conf)"

.SS "esp_err_t _gn_init_event_loop (\fBgn_config_handle_intl_t\fP config)"

.SS "\fBgn_err_t\fP _gn_init_flash (\fBgn_config_handle_t\fP conf)"

.SS "esp_err_t _gn_init_keepalive_timer (\fBgn_config_handle_intl_t\fP conf)"

.SS "esp_err_t _gn_init_spiffs (\fBgn_config_handle_intl_t\fP conf)"

.SS "void _gn_keepalive_start ()"

.SS "void _gn_keepalive_stop ()"

.SS "\fBgn_leaf_config_handle_intl_t\fP _gn_leaf_config_create ()"

.SS "void* _gn_leaf_context_add_to_leaf (const \fBgn_leaf_handle_t\fP leaf, char * key, void * value)"

.SS "void* _gn_leaf_context_get_key_to_leaf (const \fBgn_leaf_handle_t\fP leaf, char * key)"

.SS "void* _gn_leaf_context_remove_to_leaf (const \fBgn_leaf_handle_t\fP leaf, char * key)"

.SS "\fBgn_err_t\fP _gn_leaf_destroy (\fBgn_leaf_handle_t\fP leaf_config)"

.SS "void _gn_leaf_evt_handler (void * handler_args, esp_event_base_t base, int32_t id, void * event_data)"
send event to leaf, by converting the event to gn_leaf_parameter_event_handle_t struct and pass in leaf event queue\&. if the event is a leaf parameter event, event_data will be passed in the queue\&. if the event is different, event_data will be copied and null terminated in the character array data\&. 
.SS "\fBgn_leaf_config_handle_intl_t\fP _gn_leaf_get_by_name (char * leaf_name)"

.SS "\fBgn_err_t\fP _gn_leaf_param_destroy (\fBgn_leaf_param_handle_t\fP param)"

.SS "\fBgn_err_t\fP _gn_leaf_parameter_update (const \fBgn_leaf_handle_t\fP leaf_config, const char * param, const void * data, const int data_len)"
update the parameter value from the event supplied\&. this is called from event handling system\&. hence, the parameter value can be changed here only if it has WRITE access
.PP
\fBReturns\fP
.RS 4
ESP_OK if parameter is changed, 
.RE
.PP

.SS "\fBgn_err_t\fP _gn_leaf_start (\fBgn_leaf_config_handle_intl_t\fP leaf_config)"

.PP
start the leaf by starting a new task and subscribing to network messages 
.PP
\fBParameters\fP
.RS 4
\fIleaf_config\fP the leaf to start
.RE
.PP
\fBReturns\fP
.RS 4
status of the operation 
.RE
.PP

.SS "\fBgn_node_config_handle_intl_t\fP _gn_node_config_create ()"

.SS "\fBgn_err_t\fP _gn_send_event_to_leaf (\fBgn_leaf_config_handle_intl_t\fP leaf_config, \fBgn_leaf_parameter_event_handle_t\fP evt)"

.PP
send event to leaf using xQueueSend\&. the data will be null terminated\&. 
.PP
\fBParameters\fP
.RS 4
\fIleaf_config\fP the leaf from where the event is sent 
.br
\fIevt\fP the event to send
.RE
.PP
\fBReturns\fP
.RS 4
GN_ERR_EVENT_NOT_SENT if not possible to send event 
.RE
.PP

.SS "static bool IRAM_ATTR _gn_timer_callback_isr (void * args)\fC [static]\fP"

.SS "ESP_EVENT_DEFINE_BASE (\fBGN_BASE_EVENT\fP)"

.SS "ESP_EVENT_DEFINE_BASE (\fBGN_LEAF_EVENT\fP)"

.SS "\fBgn_err_t\fP gn_firmware_update ()"

.PP
send a message to the display implemented by sending an internal GN_DISPLAY_LOG_EVENT event NOTE: data will be truncated depending on display size
.PP
\fBParameters\fP
.RS 4
\fImessage\fP the message to send (null terminated)
.RE
.PP
\fBReturns\fP
.RS 4
GN_RET_OK if event is dispatched 
.PP
GN_RET_ERR if the event dispatch encounters a problem 
.PP
GN_RET_ERR_INVALID_ARG if message is NULL or zero length
.RE
.PP
starts the OTA firmware upgrade
.PP
it starts the OTA tasks so it returns immediately
.PP
\fBReturns\fP
.RS 4
GN_RET_OK 
.RE
.PP

.SS "esp_event_loop_handle_t gn_get_event_loop (\fBgn_config_handle_t\fP config)"

.PP
retrieves the event loop starting from the config handle 
.PP
\fBParameters\fP
.RS 4
\fIconfig\fP the config handle
.RE
.PP
\fBReturns\fP
.RS 4
the event loop 
.PP
NULL if config not valid 
.RE
.PP

.SS "\fBgn_node_status_t\fP gn_get_status (\fBgn_config_handle_t\fP config)\fC [inline]\fP"

.PP
retrieves the configuration status 
.PP
\fBParameters\fP
.RS 4
\fIconfig\fP the configuration handle to check
.RE
.PP
\fBReturns\fP
.RS 4
GN_CONFIG_STATUS_ERROR if config is NULL 
.PP
the configuration status 
.RE
.PP

.SS "const char* gn_get_status_description (\fBgn_config_handle_t\fP config)\fC [inline]\fP"

.PP
retrieves the configuration status description 
.PP
\fBParameters\fP
.RS 4
\fIconfig\fP the configuration handle to check
.RE
.PP
\fBReturns\fP
.RS 4
GN_CONFIG_STATUS_ERROR if config is NULL 
.PP
the configuration status 
.RE
.PP

.SS "\fBgn_config_handle_t\fP gn_init (\fBgn_config_init_param_t\fP * config_init)"

.PP
performs the initialization workflow 
.IP "\(bu" 2
creates the configuration handle
.IP "\(bu" 2
initializes hardware (flash, storage)
.IP "\(bu" 2
initializes event loop and handlers
.IP "\(bu" 2
initializes display if configured
.IP "\(bu" 2
initializes network if configured (starting provisioning is not set)
.IP "\(bu" 2
initializes server connection
.PP
.PP
this is a process that will continue even after the function returns, eg for network/server connection
.PP
when everything is OK it sets the status of the config handle to GN_CONFIG_STATUS_ERROR
.PP
NOTE: if called several times, it returns always the same handle
.PP
\fBReturns\fP
.RS 4
an handle to the config data structure 
.RE
.PP

.SS "\fBgn_leaf_handle_t\fP gn_leaf_create (\fBgn_node_handle_t\fP node_config, const char * name, \fBgn_leaf_config_callback\fP callback, size_t task_size)"

.PP
creates the leaf initializes the leaf structure\&. the returned handle is not active and need to be started by the \fBgn_node_start()\fP function 
.PP
\fBSee also\fP
.RS 4
\fBgn_node_start()\fP 
.RE
.PP
\fBParameters\fP
.RS 4
\fInode_config\fP the configuration handle to create the leaf to 
.br
\fIname\fP the name of the leaf to be created 
.br
\fIcallback\fP the callback to be called to configure the leaf 
.br
\fItask\fP callback function of the leaf task 
.br
\fItask_size\fP the size of the task to be memory allocated
.RE
.PP
\fBReturns\fP
.RS 4
an handle to the leaf config 
.PP
NULL if the handle cannot be created 
.RE
.PP

.SS "\fBgn_err_t\fP gn_leaf_event_subscribe (\fBgn_leaf_handle_t\fP leaf_config, \fBgn_event_id_t\fP event_id)"

.PP
subscribe the leaf to the event id\&. 
.PP
\fBReturns\fP
.RS 4
GN_RET_OK if successful 
.RE
.PP

.SS "\fBgn_err_t\fP gn_leaf_event_unsubscribe (\fBgn_leaf_handle_t\fP leaf_config, \fBgn_event_id_t\fP event_id)"

.PP
unsubscribe the leaf to the event id\&. 
.PP
\fBReturns\fP
.RS 4
GN_RET_OK if successful 
.RE
.PP

.SS "\fBgn_leaf_handle_t\fP gn_leaf_get_config_handle (\fBgn_node_handle_t\fP node, const char * name)"

.SS "\fBgn_leaf_descriptor_handle_t\fP gn_leaf_get_descriptor (\fBgn_leaf_handle_t\fP leaf_config)"
returns the descriptor handle for the corresponding leaf 
.SS "esp_event_loop_handle_t gn_leaf_get_event_loop (\fBgn_leaf_handle_t\fP leaf_config)"

.PP
retrieves the event loop starting from the leaf config handle 
.PP
\fBParameters\fP
.RS 4
\fIleaf_config\fP the leaf config handle
.RE
.PP
\fBReturns\fP
.RS 4
the event loop 
.PP
NULL if leaf config not valid 
.RE
.PP

.SS "QueueHandle_t gn_leaf_get_event_queue (\fBgn_leaf_handle_t\fP leaf_config)"

.PP
gets the leaf queue handle 
.PP
\fBParameters\fP
.RS 4
\fIleaf_config\fP the leaf to be queried
.RE
.PP
\fBReturns\fP
.RS 4
the queue handle 
.PP
NULL if leaf not found 
.RE
.PP

.SS "\fBgn_err_t\fP gn_leaf_get_name (\fBgn_leaf_handle_t\fP leaf_config, char * name)"

.PP
gets the name of the leaf referenced by the handle 
.PP
\fBParameters\fP
.RS 4
\fIleaf_config\fP the handle to be queried 
.br
\fIname\fP the pointer where the name will be set\&. set lenght to GN_LEAF_NAME_SIZE
.RE
.PP
\fBReturns\fP
.RS 4
GN_RET_ERR_INVALID_ARG if the handle is not valid 
.PP
GN_RET_OK if everything OK 
.RE
.PP

.SS "\fBgn_node_handle_t\fP gn_leaf_get_node (\fBgn_leaf_handle_t\fP leaf_config)"

.SS "\fBgn_leaf_param_handle_t\fP gn_leaf_get_params (\fBgn_leaf_handle_t\fP leaf_config)"

.PP
returns the first parameter associated to the leaf 
.PP
\fBParameters\fP
.RS 4
\fIleaf_config\fP the leaf handle to search within
.RE
.PP
\fBReturns\fP
.RS 4
NULL if leaf_config is not found 
.PP
the first parameter handle 
.RE
.PP

.SS "\fBgn_err_t\fP gn_leaf_param_add_to_leaf (const \fBgn_leaf_handle_t\fP leaf, const \fBgn_leaf_param_handle_t\fP param)"

.PP
add a parameter to the leaf\&. the parameter will then listen to server changes
.PP
\fBParameters\fP
.RS 4
\fIleaf\fP the leaf handle 
.br
\fIparam\fP the param to add to the leaf\&. the leaf will point at it upon method return
.RE
.PP
\fBReturns\fP
.RS 4
GN_RET_ERR_INVALID_ARG in case of parameter errors 
.PP
GN_RET_OK upon success 
.RE
.PP

.SS "\fBgn_leaf_param_handle_t\fP gn_leaf_param_create (\fBgn_leaf_handle_t\fP leaf_config, const char * name, const \fBgn_val_type_t\fP type, \fBgn_val_t\fP val, \fBgn_leaf_param_access_type_t\fP access, \fBgn_leaf_param_storage_t\fP storage, \fBgn_validator_callback_t\fP validator)"

.PP
.nf
@brief  creates a parameter on the leaf

NOTE: if parameter is stored, the value is overridden

.fi
.PP
 
.PP
\fBParameters\fP
.RS 4
\fIleaf_config\fP the leaf to be queried 
.br
\fIname\fP the name of the parameter (null terminated char array) 
.br
\fItype\fP the type of parameter 
.br
\fIval\fP the value of parameter 
.br
\fIaccess\fP access type of parameter 
.br
\fIstorage\fP storage type of parameter 
.br
\fIvalidator\fP callback to validate
.RE
.PP
\fBReturns\fP
.RS 4
the new parameter handle 
.PP
NULL in case of errors 
.RE
.PP

.SS "\fBgn_err_t\fP gn_leaf_param_get_bool (const \fBgn_leaf_handle_t\fP leaf_config, const char * name, bool * val)"

.SS "\fBgn_err_t\fP gn_leaf_param_get_double (const \fBgn_leaf_handle_t\fP leaf_config, const char * name, double * val)"

.SS "\fBgn_leaf_param_handle_t\fP gn_leaf_param_get_param_handle (const \fBgn_leaf_handle_t\fP leaf_config, const char * param_name)"

.PP
returns the specific parameter associated to the leaf 
.PP
\fBParameters\fP
.RS 4
\fIleaf_config\fP the leaf handle to search within 
.br
\fIparam_name\fP the name of the parameter (null terminated)
.RE
.PP
\fBReturns\fP
.RS 4
NULL if leaf_config or the parameter is not found 
.PP
the found parameter handle 
.RE
.PP

.SS "\fBgn_err_t\fP gn_leaf_param_get_string (const \fBgn_leaf_handle_t\fP leaf_config, const char * name, char * val, size_t max_lenght)"

.PP
gets the parameter value 
.PP
\fBParameters\fP
.RS 4
\fIleaf_config\fP the leaf to get the parameter from 
.br
\fIname\fP the name of the parameter, null terminated 
.br
\fIval\fP pointer where the parameter is put 
.br
\fImax_lenght\fP the maximum lenght of the parameter value to be copied 
.PP
.nf
@return GN_RET_OK if the parameter is set
@return GN_RET_ERR_INVALID_ARG if the parameter is not found

.fi
.PP
 
.RE
.PP

.SS "\fBgn_err_t\fP gn_leaf_param_get_value (const \fBgn_leaf_param_handle_t\fP param, void * val)"

.PP
gets the value pointed by the parameter 
.PP
\fBParameters\fP
.RS 4
\fIparam\fP the parameter handle to look at 
.br
\fIval\fP the value returned 
.PP
.nf
@return GN_RET_OK if the parameter is set
@return GN_RET_ERR_INVALID_ARG in case of input errors

.fi
.PP
 
.RE
.PP

.SS "\fBgn_err_t\fP gn_leaf_param_init_bool (const \fBgn_leaf_handle_t\fP leaf_config, const char * name, bool val)"

.PP
init the parameter with new value and stores in NVS flash, overwriting previous values the leaf must be not initialized to have an effect\&. the parameter value will be copied to the corresponding handle\&.
.PP
\fBParameters\fP
.RS 4
\fIleaf_config\fP the leaf handle to be queried 
.br
\fIname\fP the name of the parameter (null terminated) 
.br
\fIval\fP the value to set
.RE
.PP
\fBReturns\fP
.RS 4
GN_RET_OK if the parameter is set 
.PP
GN_RET_ERR_INVALID_ARG in case of input errors 
.RE
.PP

.SS "\fBgn_err_t\fP gn_leaf_param_init_double (const \fBgn_leaf_handle_t\fP leaf_config, const char * name, double val)"

.PP
init the parameter with new value and stores in NVS flash, overwriting previous values the leaf must be not initialized to have an effect\&. the parameter value will be copied to the corresponding handle\&.
.PP
\fBParameters\fP
.RS 4
\fIleaf_config\fP the leaf handle to be queried 
.br
\fIname\fP the name of the parameter (null terminated) 
.br
\fIval\fP the value to set
.RE
.PP
\fBReturns\fP
.RS 4
GN_RET_OK if the parameter is set 
.PP
GN_RET_ERR_INVALID_ARG in case of input errors 
.RE
.PP

.SS "\fBgn_err_t\fP gn_leaf_param_init_string (const \fBgn_leaf_handle_t\fP leaf_config, const char * name, const char * val)"

.PP
init the parameter with new value and stores in NVS flash, overwriting previous values the leaf must be not initialized to have an effect\&. the parameter value will be copied to the corresponding handle\&.
.PP
\fBParameters\fP
.RS 4
\fIleaf_config\fP the leaf handle to be queried 
.br
\fIname\fP the name of the parameter (null terminated) 
.br
\fIval\fP the value to set
.RE
.PP
\fBReturns\fP
.RS 4
GN_RET_OK if the parameter is set 
.PP
GN_RET_ERR_INVALID_ARG in case of input errors 
.RE
.PP

.SS "\fBgn_err_t\fP gn_leaf_param_set_bool (const \fBgn_leaf_handle_t\fP leaf_config, const char * name, bool val)"

.PP
updates the parameter with new value the parameter value will be copied to the corresponding handle\&. after the change the parameter change will be propagated to the event system through a GN_LEAF_PARAM_CHANGED_EVENT and to the server\&.
.PP
\fBParameters\fP
.RS 4
\fIleaf_config\fP the leaf handle to be queried 
.br
\fIname\fP the name of the parameter (null terminated) 
.br
\fIval\fP the value to set (null terminated)
.RE
.PP
\fBReturns\fP
.RS 4
GN_RET_OK if the parameter is set 
.PP
GN_RET_ERR_INVALID_ARG in case of input errors 
.RE
.PP

.SS "\fBgn_err_t\fP gn_leaf_param_set_double (const \fBgn_leaf_handle_t\fP leaf_config, const char * name, double val)"

.PP
updates the parameter with new value the leaf must be already initialized to have an effect\&. the parameter value will be copied to the corresponding handle\&. after the change the parameter change will be propagated to the event system through a GN_LEAF_PARAM_CHANGED_EVENT and to the server\&.
.PP
\fBParameters\fP
.RS 4
\fIleaf_config\fP the leaf handle to be queried 
.br
\fIname\fP the name of the parameter (null terminated) 
.br
\fIval\fP the value to set
.RE
.PP
\fBReturns\fP
.RS 4
GN_RET_OK if the parameter is set 
.PP
GN_RET_ERR_INVALID_ARG in case of input errors 
.RE
.PP

.SS "\fBgn_err_t\fP gn_leaf_param_set_string (const \fBgn_leaf_handle_t\fP leaf_config, const char * name, char * val)"

.PP
updates the parameter with new value the parameter value will be copied to the corresponding handle\&. after the change the parameter change will be propagated to the event system through a GN_LEAF_PARAM_CHANGED_EVENT and to the server\&.
.PP
\fBParameters\fP
.RS 4
\fIleaf_config\fP the leaf handle to be queried 
.br
\fIname\fP the name of the parameter (null terminated) 
.br
\fIval\fP the value to set (null terminated)
.RE
.PP
\fBReturns\fP
.RS 4
GN_RET_OK if the parameter is set 
.PP
GN_RET_ERR_INVALID_ARG in case of input errors 
.PP
GN_RET_ERR in case of messaging error 
.RE
.PP

.SS "\fBgn_err_t\fP gn_leaf_param_set_value (const \fBgn_leaf_param_handle_t\fP param_handle, const void * value)"

.PP
.nf
@brief  updates the parameter with new value

.fi
.PP
 this is calling the gn_leaf_parameter_set_XXX depending on the param handle type, so be careful in order to avoid memory leaks 
.PP
.nf
@param leaf_config  the leaf handle to be queried
@param value        the pointer to value to set ( in case of string, null terminated)

@return GN_RET_OK if the parameter is set
@return GN_RET_ERR_INVALID_ARG in case of input errors

.fi
.PP
 
.SS "\fBgn_err_t\fP gn_leaf_param_update_bool (const \fBgn_leaf_handle_t\fP leaf_config, const char * name, bool val)"

.PP
generate a request to update the parameter to the leaf\&. This is different from the corresponding 'set' method as it inform the leaf that a parameter should be changed\&. Think of it as it would be requested by the network\&. It is the basis of inter-leaves messaging\&.
.PP
\fBParameters\fP
.RS 4
\fIleaf_config\fP the leaf to ask 
.br
\fIname\fP the parameter name to change 
.br
\fIval\fP the value to change 
.PP
.nf
@return GN_RET_ERR_LEAF_NOT_FOUND if the leaf is not found
@return GN_RET_ERR_INVALID_ARG in case of input parameter error
@return GN_RET_ERR_LEAF_PARAM_ACCESS_VIOLATION in case the parameter access is not write enable

.fi
.PP
 
.RE
.PP

.SS "\fBgn_err_t\fP gn_leaf_param_update_double (const \fBgn_leaf_handle_t\fP leaf_config, const char * name, double val)"

.PP
generate a request to update the parameter to the leaf\&. This is different from the corresponding 'set' method as it inform the leaf that a parameter should be changed\&. Think of it as it would be requested by the network\&. It is the basis of inter-leaves messaging\&.
.PP
\fBParameters\fP
.RS 4
\fIleaf_config\fP the leaf to ask 
.br
\fIname\fP the parameter name to change 
.br
\fIval\fP the value to change 
.PP
.nf
@return GN_RET_ERR_LEAF_NOT_FOUND if the leaf is not found
@return GN_RET_ERR_INVALID_ARG in case of input parameter error
@return GN_RET_ERR_LEAF_PARAM_ACCESS_VIOLATION in case the parameter access is not write enable

.fi
.PP
 
.RE
.PP

.SS "\fBgn_err_t\fP gn_leaf_param_update_string (const \fBgn_leaf_handle_t\fP leaf_config, const char * name, char * val)"

.PP
generate a request to update the parameter to the leaf\&. This is different from the corresponding 'set' method as it inform the leaf that a parameter should be changed\&. Think of it as it would be requested by the network\&. It is the basis of inter-leaves messaging\&.
.PP
\fBParameters\fP
.RS 4
\fIleaf_config\fP the leaf to ask 
.br
\fIname\fP the parameter name to change 
.br
\fIval\fP the value to change 
.PP
.nf
@return GN_RET_ERR_LEAF_NOT_FOUND if the leaf is not found
@return GN_RET_ERR_INVALID_ARG in case of input parameter error
@return GN_RET_ERR_LEAF_PARAM_ACCESS_VIOLATION in case the parameter access is not write enable

.fi
.PP
 
.RE
.PP

.SS "\fBgn_err_t\fP gn_log (char * log_tag, \fBgn_log_level_t\fP level, const char * message,  \&.\&.\&.)"

.PP
write ESP log, send log in the event queue and publish in network 
.PP
\fBParameters\fP
.RS 4
\fIlog_tag\fP log level, will be the TAG in ESP logging framework 
.br
\fIlevel\fP grownode log level 
.br
\fImessage\fP the null terminated message to log 
.PP
.nf
@return GN_RET_OK if event is dispatched
@return GN_RET_ERR if the event dispatch encounters a problem
@return GN_RET_ERR_INVALID_ARG if message is NULL or zero length

.fi
.PP
 
.RE
.PP

.SS "\fBgn_node_handle_t\fP gn_node_create (\fBgn_config_handle_t\fP config, const char * name)"

.PP
create a new node with specified configuration and name 
.PP
\fBParameters\fP
.RS 4
\fIconfig\fP the config handle to use 
.br
\fIname\fP name of the node\&. MUST BE null terminated
.RE
.PP
\fBReturns\fP
.RS 4
the node handle created\&. 
.RE
.PP

.SS "\fBgn_err_t\fP gn_node_destroy (\fBgn_node_handle_t\fP node)"

.PP
removes the node from the config 
.PP
\fBParameters\fP
.RS 4
\fInode\fP the node to be removed
.RE
.PP
\fBReturns\fP
.RS 4
GN_RET_OK if operation had succeded 
.RE
.PP

.SS "\fBgn_err_t\fP gn_node_get_name (\fBgn_node_handle_t\fP node_config, char * name)"

.PP
gets the name of the node referenced by the handle 
.PP
\fBParameters\fP
.RS 4
\fInode_config\fP the handle to be queried 
.br
\fIname\fP the pointer where the name will be set\&. set lenght to GN_LEAF_NAME_SIZE
.RE
.PP
\fBReturns\fP
.RS 4
GN_RET_ERR_INVALID_ARG if the handle is not valid 
.PP
GN_RET_OK if everything OK 
.RE
.PP

.SS "size_t gn_node_get_size (\fBgn_node_handle_t\fP node_config)"

.PP
number of leaves into the node 
.PP
\fBParameters\fP
.RS 4
\fInode_config\fP the node to be inspected
.RE
.PP
\fBReturns\fP
.RS 4
number of leaves into the node, -1 in case node_config is NULL 
.RE
.PP

.SS "\fBgn_err_t\fP gn_node_start (\fBgn_node_handle_t\fP node)"

.PP
starts the node by starting the leaves tasks At the end of the process, it sets the node status to GN_CONFIG_STATUS_STARTED and sends a GN_NODE_STARTED_EVENT event
.PP
\fBParameters\fP
.RS 4
\fInode\fP the node to be started
.RE
.PP
\fBReturns\fP
.RS 4
GN_RET_OK if operation had succeded, GN_RET_ERR_NODE_NOT_STARTED in case of issues 
.RE
.PP

.SS "\fBgn_err_t\fP gn_reboot ()"

.PP
reboot the board 
.PP
\fBReturns\fP
.RS 4
GN_RET_OK 
.RE
.PP

.SS "\fBgn_err_t\fP gn_reset ()"

.PP
reset the flash content and restart the board immediately 
.PP
\fBReturns\fP
.RS 4
GN_RET_OK 
.RE
.PP

.SS "\fBgn_err_t\fP gn_send_leaf_param_change_message (const char * leaf_name, const char * param_name, const void * message, size_t message_len)"

.PP
send a request to change a parameter name It sends a GN_LEAF_PARAM_CHANGE_REQUEST_EVENT to the leaf parameter, if the parameter is modifiable
.PP
\fBParameters\fP
.RS 4
\fIleaf_name\fP the leaf name (null terminated) to send the request to 
.br
\fIparam_name\fP the parameter name to change (null terminated) 
.br
\fImessage\fP a pointer to the payload 
.br
\fImessage_len\fP size of the payload
.RE
.PP
\fBReturns\fP
.RS 4
GN_RET_ERR_LEAF_NOT_FOUND if the leaf is not found 
.PP
GN_RET_ERR_INVALID_ARG in case of input parameter error 
.PP
GN_RET_ERR_LEAF_PARAM_ACCESS_VIOLATION in case the parameter access is not write enable 
.RE
.PP

.SS "\fBgn_err_t\fP gn_send_node_leaf_param_status (const \fBgn_node_handle_t\fP _node_config)"

.PP
send parameter status per each parameter 
.PP
\fBParameters\fP
.RS 4
\fI_node_config\fP the config
.RE
.PP
\fBReturns\fP
.RS 4
GN_RET_OK upon success 
.RE
.PP

.SS "\fBgn_err_t\fP gn_storage_get (const char * key, void ** value)"

.PP
retrieves the key from the NVS flash internally, this is implemented by retrieving raw bytes to the flash storage
.PP
\fBParameters\fP
.RS 4
\fIkey\fP name (null terminated) 
.br
\fIvalue\fP pointer where the pointer of the data acquired will be stored
.RE
.PP
\fBReturns\fP
.RS 4
GN_RET_ERR_INVALID_ARG if input params are not valid 
.PP
GN_RET_OK if key is stored successfully 
.RE
.PP

.SS "\fBgn_err_t\fP gn_storage_set (const char * key, const void * value, size_t required_size)"

.PP
stores the key into the NVS flash internally, this is implemented by copying raw bytes to the flash storage
.PP
\fBParameters\fP
.RS 4
\fIkey\fP name (null terminated) 
.br
\fIvalue\fP pointer to data 
.br
\fIrequired_size\fP bytes to write
.RE
.PP
\fBReturns\fP
.RS 4
GN_RET_ERR_INVALID_ARG if input params are not valid 
.PP
GN_RET_OK if key is stored successfully 
.RE
.PP

.SH "Variable Documentation"
.PP 
.SS "\fBgn_config_handle_intl_t\fP _gn_default_conf = NULL"

.SS "esp_event_loop_handle_t gn_event_loop = NULL"

.SH "Author"
.PP 
Generated automatically by Doxygen for GrowNode from the source code\&.
